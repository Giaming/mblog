/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80026
 Source Host           : localhost:3306
 Source Schema         : vueblog

 Target Server Type    : MySQL
 Target Server Version : 80026
 File Encoding         : 65001

 Date: 17/02/2022 15:12:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章标题',
  `first_picture` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '文章首图，用于随机文章展示',
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '描述',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '文章正文',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `views` int NOT NULL COMMENT '浏览次数',
  `words` int NOT NULL COMMENT '文章字数',
  `type_id` bigint NOT NULL COMMENT '文章分类id',
  `user_id` bigint DEFAULT NULL COMMENT '文章作者id',
  `status` tinyint DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of blog
-- ----------------------------
BEGIN;
INSERT INTO `blog` VALUES (1, '关于我', 'https://static.runoob.com/images/demo/demo2.jpg', '## 个人介绍', '编辑', '2020-05-22 22:05:49', '2022-02-17 14:29:14', 33, 2, 3, 1, 1);
INSERT INTO `blog` VALUES (3, '最值得学习的博客项目eblog', '', '**推荐阅读：**\r\n\r\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca', '**推荐阅读：**\r\n\r\n[分享一套SpringBoot开发博客系统源码，以及完整开发文档！速度保存！](https://mp.weixin.qq.com/s/jz6e977xP-OyaAKNjNca8w)\r\n\r\n[Github上最值得学习的100个Java开源项目，涵盖各种技术栈！](https://mp.weixin.qq.com/s/N-U0TaEUXnBFfBsmt_OESQ)\r\n\r\n[2020年最新的常问企业面试题大全以及答案](https://mp.weixin.qq.com/s/lR5LC5GnD2Gs59ecV5R0XA)', '2020-05-28 09:36:38', '2022-02-17 14:25:16', 112, 10, 1, 1, 1);
INSERT INTO `blog` VALUES (11, 'Mybatis中强大的resultMap', 'https://static.runoob.com/images/demo/demo3.jpg', 'Mybatis中强大的resultMap\n前言\n一、字段映射\n二、构造方法\n三、关联\n四、集合\n1、集合的嵌套结果映射\n2、集合的嵌套 Select 查询\n五、自动填充关联对象\n', '\n# Mybatis中强大的resultMap\n\n## 前言\n\n在`Mybatis`中，有一个强大的功能元素`resultMap`。当我们希望将`JDBC ResultSets`中的数据，转化为合理的Java对象时，你就能感受到它的非凡之处。正如其官方所述的那样：\n\n> `resultMap`元素是 `MyBatis` 中最重要最强大的元素。它可以让你从 90% 的 `JDBC ResultSets` 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 `resultMap` 能够代替实现同等功能的长达数千行的代码。`ResultMap` 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。\n\n## 一、字段映射\n\n在`Mybatis`中，最简单的结果映射方式，就是通过类型别名`typeAliases`来处理。\n\n如果要这样做，那么第一步需要配置实体类包的路径：\n\n```\nmybatis.type-aliases-package=com.xxx.entity\n```\n\n该路径下的所有类，就会被注册到`TYPE_ALIASES容器`。我们在指定返回值类型的时候，就直接用别名即可。\n\n比如，我们有一个`User`类：\n\n```\n@Data\npublic class User {\n    private String id;\n    private String username;\n    private String password;\n    private String address;\n    private String email;\n}\n复制代码\n```\n\n如果数据库中表的字段与`User`类的属性名称一致，我们就可以使用`resultType`来返回。\n\n```\n<select id=\"getUsers\" resultType=\"User\">\n	SELECT\n		u.id,\n		u.username,\n		u.password,\n		u.address,\n		u.email\n	FROM\n		USER u\n</select>\n复制代码\n```\n\n当然，这是理想状态下，属性和字段名都完全一致的情况。但事实上，不一致的情况是有的，这时候我们的`resultMap`就要登场了。\n\n如果`User`类保持不变，但`SQL`语句发生了变化，将`id`改成了`uid`。\n\n```\n<select id=\"getUsers\" resultType=\"User\">\n	SELECT\n		u.id as uid,\n		u.username,\n		u.password,\n		u.address,\n		u.email\n	FROM\n		USER u\n</select>\n复制代码\n```\n\n那么，在结果集中，我们将会丢失`id`数据。这时候我们就可以定义一个`resultMap`，来映射不一样的字段。\n\n```\n<resultMap id=\"getUserByIdMap\" type=\"User\">\n	<result property=\"id\" column=\"uid\"></result>\n</resultMap>\n复制代码\n```\n\n然后，我们把上面的`select`语句中的`resultType`修改为`resultMap=\"getUserByIdMap\"`。\n\n这里面`column`对应的是数据库的列名或别名；`property`对应的是结果集的字段或属性。\n\n这就是`resultMap`最简单，也最基础的用法：字段映射。\n\n下面，我们看看其他几种标签都是怎么应用的。\n\n| 元素名称    | 描述                                   |\n| ----------- | -------------------------------------- |\n| constructor | 用于在实例化类时，注入结果到构造方法中 |\n| association | 关联一个对象                           |\n| collection  | 关联多个对象                           |\n\n## 二、构造方法\n\n如果你希望将结果注入构造方法里，就可以用到`constructor`元素。\n\n比如，我们的`User`类增加了一个构造方法：\n\n```\npublic User(String id, String name) {\n	this.id = id+\"--------\";\n	this.username = name+\"--------\";\n}\n复制代码\n```\n\n我们需要在`resultMap`中定义`constructor`元素：\n\n```\n<resultMap id=\"getUserByIdMap\" type=\"User\">\n	<constructor>\n		<idArg column=\"id\" name=\"id\" javaType=\"string\"></idArg>\n		<arg column=\"username\" name=\"name\" javaType=\"string\"></arg>\n	</constructor>\n</resultMap>\n复制代码\n```\n\n其中，`column`代表数据库字段名称或者别名；`name`则是构造方法中的参数名称；`javaType`指定了参数的类型。\n\n如你所想，这样指定构造方法后，我们结果集中的`id和username`属性都会发生变化。\n\n```\n{\n    \"id\": \"1001--------\",\n    \"username\": \"后羿--------\",\n    \"password\": \"123456\",\n    \"address\": \"北京市海淀区\",\n    \"email\": \"510273027@qq.com\"\n}\n复制代码\n```\n\n## 三、关联\n\n在实际的业务中，我们的用户一般都会有一个角色。那么在`User`类里面一般也是以一个实体类来表示。\n\n```\n@Data\npublic class User {\n    //省略用户属性...\n	\n    //角色信息\n    private Role role;\n}\n复制代码\n```\n\n我们在查询用户的时候，如果也希望看到它的角色信息，我们会这样来写查询语句：\n\n```\n<select id=\"getUserById\" resultType=\"User\">\n        SELECT\n            u.id,\n            u.username,\n            u.password,\n            u.address,\n            u.email,\n            r.id as \'role_id\',\n            r.name as \'role_name\'\n        FROM\n            USER u\n                LEFT JOIN user_roles ur ON u.id = ur.user_id\n                LEFT JOIN role r ON r.id = ur.role_id\n        where u.id=#{id}\n    </select>\n复制代码\n```\n\n如上，就要查询单个用户以及用户的角色信息。不过在这里，我们不能用`resultType=User`来返回。\n\n毕竟，`User`类中只有一个`Role`对象，并没有`role_id和role_name`字段属性。\n\n所以，我们要使用`association`来关联它们。\n\n```\n<resultMap id=\"userMap\" type=\"User\">\n	<id property=\"id\" column=\"id\"></id>\n	<result property=\"username\" column=\"username\"></result>\n	<result property=\"password\" column=\"password\"></result>\n	<result property=\"address\" column=\"address\"></result>\n	<result property=\"email\" column=\"email\"></result>\n	\n	<association property=\"role\" javaType=\"Role\">\n		<id property=\"id\" column=\"role_id\"></id>\n		<result property=\"name\" column=\"role_name\"></result>\n	</association>\n</resultMap>\n复制代码\n```\n\n最后我们就可以将角色信息一块显示出来：\n\n```\n{\n    \"id\": \"1001\",\n    \"username\": \"后羿\",\n    \"password\": \"123456\",\n    \"address\": \"北京市海淀区\",\n    \"email\": \"510273027@qq.com\",\n    \"role\": {\n        \"id\": \"3\",\n        \"name\": \"射手\"\n    }\n}\n复制代码\n```\n\n事实上，如果你确定关联信息是`一对一`的情况，有个更简便的方法可以替代`association`，我们在本文的`第五部分-自动填充关联对象`再看它是怎么实现的。\n\n## 四、集合\n\n#### 1、集合的嵌套结果映射\n\n上面我们看到一个用户`后羿`，它的角色是`射手`；但大部分时候，我们每个人都不可能只拥有一种角色。所以，我们需要将`User`类中的角色属性的类型改成`List`。\n\n```\n@Data\npublic class User {\n    //省略用户属性...\n	\n    //角色信息\n    private List<Role> roles;\n}\n复制代码\n```\n\n现在就变成了一个用户对应多个角色，所以就不是简单的`association`。\n\n因为`association`处理的是`有一个`类型的关联；而我们这里是`有多个`类型的关联，所以就需要用到`collection`属性。\n\n我们整体的`resultMap`会变成下面这样：\n\n```\n<resultMap id=\"userMap\" type=\"User\">\n	<id property=\"id\" column=\"id\"></id>\n	<result property=\"username\" column=\"username\"></result>\n	<result property=\"password\" column=\"password\"></result>\n	<result property=\"address\" column=\"address\"></result>\n	<result property=\"email\" column=\"email\"></result>\n	\n	<collection property=\"roles\" ofType=\"Role\">\n		<id property=\"id\" column=\"role_id\"></id>\n		<result property=\"name\" column=\"role_name\"></result>\n	</collection>\n</resultMap>\n复制代码\n```\n\n这样的话，即便你有多个角色也可以被正确显示：\n\n```\n{\n    \"id\": \"1003\",\n    \"username\": \"貂蝉\",\n    \"password\": \"123456\",\n    \"address\": \"北京市东城区\",\n    \"email\": \"510273027@qq.com\",\n    \"roles\": [\n        {\n            \"id\": \"1\",\n            \"name\": \"中单\"\n        },\n        {\n            \"id\": \"2\",\n            \"name\": \"打野\"\n        }\n    ]\n}\n复制代码\n```\n\n#### 2、集合的嵌套 Select 查询\n\n在大部分业务系统中，我们都会有一个菜单的表，比如像下面这样，一张`Menu`表：\n\n| id   | name     | url             | parent_id |\n| ---- | -------- | --------------- | --------- |\n| 1    | 系统管理 |                 | 0         |\n| 1001 | 用户管理 | /user           | 1         |\n| 1002 | 角色管理 | /role           | 1         |\n| 1003 | 单位管理 | /employer       | 1         |\n| 2    | 平台监控 |                 | 0         |\n| 2001 | 系统监控 | /system/monitor | 2         |\n| 2002 | 数据监控 | /data/monitor   | 2         |\n\n这里我们给菜单分为两级。我们给前端返回菜单的时候，也是需要分级的，不可能将这7条数据平级展示。那么，在这里我们的`Menu`实体类如下：\n\n```\n@Data\npublic class Menu {\n    private String id;\n    private String name;\n    private String url;\n    private String parent_id;\n    private List<Menu> childMenu;\n}\n复制代码\n```\n\n一级菜单，包含一个二级菜单的列表，这里用`childMenu`来表示。\n\n`SQL`语句中，如果没有`parent_id`字段属性，我们就先查所有的一级菜单：\n\n```\n<select id=\"getMenus\" resultMap=\"menusMap\">\n	SELECT\n		m.id,\n		m.name,\n		m.url,\n		m.parent_id\n	FROM\n		m_menu m\n	where 1=1\n	<choose>\n		<when test=\"parent_id!=null\">\n			and m.parent_id = #{parent_id}\n		</when>\n		<otherwise>\n			and m.parent_id = \'0\'\n		</otherwise>\n	</choose>\n</select>\n复制代码\n```\n\n这个查询语句，在不传输任何参数的情况下，我们会得到两条一级菜单的数据。\n\n那么在只调用此方法一次的情况下，怎么把所有的菜单信息查询出来，并按层级展示呢？\n\n我们来看`menusMap`的定义：\n\n```\n<resultMap id=\"menusMap\" type=\"Menu\">\n	<id property=\"id\" column=\"id\"></id>\n	<result property=\"name\" column=\"name\"></result>\n	<result property=\"url\" column=\"url\"></result>\n	<result property=\"m_desc\" column=\"m_desc\"></result>\n	<result property=\"parent_id\" column=\"parent_id\"></result>\n	\n	<collection property=\"childMenu\" ofType=\"Menu\" select=\"getMenus\"  column=\"{parent_id=id}\"></collection>\n</resultMap>\n复制代码\n```\n\n重点来看`collection`元素：\n\n`property=\"childMenu\"` 对应的是菜单中的子级菜单列表；\n\n`ofType=\"Menu\"` 对应返回数据的类型；\n\n`select=\"getMenus\"` 指定了`SELECT`语句的id；\n\n`column=\"{parent_id=id}\"` 则是参数的表达式。\n\n这个`collection`整体的含义可以这样理解：\n\n通过`getMenus`这个`SELECT语句`来获取一级菜单中的`childMenu`属性结果；在上面的`SELECT语句`中，需要传递一个`parent_id`参数；这个参数的值就是一级菜单中的`id`。\n\n通过这种方式，我们就可以得到已分级的所有菜单信息。\n\n```\n[\n    {\n        \"id\": \"1\",\n        \"name\": \"系统管理\",\n        \"parent_id\": \"0\",\n        \"childMenu\": [\n            {\n                \"id\": \"1001\",\n                \"name\": \"用户管理\",\n                \"url\": \"/user\",\n                \"parent_id\": \"1\"\n            },\n            {\n                \"id\": \"1002\",\n                \"name\": \"角色管理\",\n                \"url\": \"/role\",\n                \"parent_id\": \"1\"\n            },\n            {\n                \"id\": \"1003\",\n                \"name\": \"单位管理\",\n                \"url\": \"/employer\",\n                \"parent_id\": \"1\"\n            }\n        ]\n    },\n    {\n        \"id\": \"2\",\n        \"name\": \"平台监控\",\n        \"parent_id\": \"0\",\n        \"childMenu\": [\n            {\n                \"id\": \"2001\",\n                \"name\": \"系统监控\",\n                \"url\": \"/system/monitor\",\n                \"parent_id\": \"2\"\n            },\n            {\n                \"id\": \"2002\",\n                \"name\": \"数据监控\",\n                \"url\": \"/data/monitor\",\n                \"parent_id\": \"2\"\n            }\n        ]\n    }\n]\n复制代码\n```\n\n## 五、自动填充关联对象\n\n我们知道，在`Mybatis`解析返回值的时候。\n\n第一步是获取返回值类型，拿到`Class`对象，然后获取构造器，设置可访问并返回实例，然后又把它包装成`MetaObject`对象。\n\n从数据库`rs`中拿到结果之后，会调用`MetaObject.setValue(String name, Object value)` 来填充对象。\n\n在这过程中，有趣的是，它会以`.`来分隔这个`name`属性。\n\n如果`name`属性中包含`.符号`，就找到`.符号`之前的属性名称，把它当做一个实体对象来处理。\n\n可能笔者在这里描述的不够直观，我们还是来看例子。\n\n在本文`第三部分`中，我们有`一个用户对应一个角色`的例子。\n\n其中，`User`类定义如下：\n\n```\n@Data\npublic class User {\n    //省略用户属性...\n	\n    //角色信息\n    private Role role;\n}\n复制代码\n```\n\n在这里，我们无需定义`resultMap`，直接返回`resultType=User`即可。不过需要把`role`信息的别名修改一下，重点是`.符号`\n\n```\n<select id=\"getUserList\" resultType=\"User\">\n	SELECT\n		u.id,\n		u.username,\n		u.password,\n		u.address,\n		u.email,\n		r.id as \'role.id\',\n		r.name as \'role.name\'\n	FROM\n		USER u\n			LEFT JOIN user_roles ur ON u.id = ur.user_id\n			LEFT JOIN role r ON r.id = ur.role_id\n</select>\n复制代码\n```\n\n这样，在`Mybatis`解析到`role.id`属性的时候，以`.符号`分隔之后发现，`role`别名对应的是`Role`对象，则会先初始化`Role`对象，并将值赋予`id`属性。\n\n\n作者：清幽之地\n链接：https://juejin.cn/post/6844903858477481992\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。', '2022-02-17 14:40:25', '2022-02-17 14:40:25', 11, 9239, 2, 1, 1);
INSERT INTO `blog` VALUES (12, 'JavaEE 之 Cookie 和 Session ', 'https://static.runoob.com/images/demo/demo4.jpg', '## Cookie 和 Session ', '# JavaEE 之 Cookie 和 Session\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-cookie)1. Cookie\n\n由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。\n\n会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-1-cookie-是什么)1.1. Cookie 是什么\n\nCookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。\n\n**Cookie 工作步骤：**\n\n1. 客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。\n2. 客户端浏览器会把 Cookie 保存下来。\n3. 当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。\n\n***注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。***\n\nJava 中把 Cookie 封装成了`javax.servlet.http.Cookie`类。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-2-cookie-剖析)1.2. Cookie 剖析\n\nCookies 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。\n\n设置 Cookie 的 Servlet 会发送如下的头信息：\n\n```http\nHTTP/1.1 200 OK\nDate: Fri, 04 Feb 2000 21:03:38 GMT\nServer: Apache/1.3.9 (UNIX) PHP/4.0b3\nSet-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT;\n                 path=/; domain=w3cschool.cc\nConnection: close\nContent-Type: text/html\n```\n\n正如您所看到的，`Set-Cookie` 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后\"忘记\"该 Cookie。\n\n如果浏览器被配置为存储 Cookies，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：\n\n```http\nGET / HTTP/1.0\nConnection: Keep-Alive\nUser-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)\nHost: zink.demon.co.uk:1126\nAccept: image/gif, */*\nAccept-Encoding: gzip\nAccept-Language: en\nAccept-Charset: iso-8859-1,*,utf-8\nCookie: name=xyz\n```\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-3-cookie-类中的方法)1.3. Cookie 类中的方法\n\n| 方法                                   | 功能                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| public void setDomain(String pattern)  | 该方法设置 cookie 适用的域。                                 |\n| public String getDomain()              | 该方法获取 cookie 适用的域。                                 |\n| public void setMaxAge(int expiry)      | 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。 |\n| public int getMaxAge()                 | 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。 |\n| public String getName()                | 该方法返回 cookie 的名称。名称在创建后不能改变。             |\n| public void setValue(String newValue)  | 该方法设置与 cookie 关联的值。                               |\n| public String getValue()               | 该方法获取与 cookie 关联的值。                               |\n| public void setPath(String uri)        | 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。 |\n| public String getPath()                | 该方法获取 cookie 适用的路径。                               |\n| public void setSecure(boolean flag)    | 该方法设置布尔值，向浏览器指示，只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。 |\n| public void setComment(String purpose) | 该方法规定了描述 cookie 目的的注释。该注释在浏览器向用户呈现 cookie 时非常有用。 |\n| public String getComment()             | 该方法返回了描述 cookie 目的的注释，如果 cookie 没有注释则返回 null。 |\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-4-cookie-的有效期)1.4. Cookie 的有效期\n\n`Cookie`的`maxAge`决定着 Cookie 的有效期，单位为秒。\n\n如果 maxAge 为 0，则表示删除该 Cookie；\n\n如果为负数，表示该 Cookie 仅在本浏览器中以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。\n\nCookie 中提供`getMaxAge()`**和**`setMaxAge(int expiry)`方法来读写`maxAge`属性。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-5-cookie-的域名)1.5. Cookie 的域名\n\nCookie 是不可以跨域名的。域名 www.google.com 颁发的 Cookie 不会被提交到域名 www.baidu.com 去。这是由 Cookie 的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的 Cookie。\n\n正常情况下，同一个一级域名的两个二级域名之间也不能互相使用 Cookie。如果想让某域名下的子域名也可以使用该 Cookie，需要设置 Cookie 的 domain 参数。\n\nJava 中使用`setDomain(Stringdomain)`和`getDomain()`方法来设置、获取 domain。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-6-cookie-的路径)1.6. Cookie 的路径\n\nPath 属性决定允许访问 Cookie 的路径。\n\nJava 中使用`setPath(Stringuri)`和`getPath()`方法来设置、获取 path。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-7-cookie-的安全属性)1.7. Cookie 的安全属性\n\nHTTP 协议不仅是无状态的，而且是不安全的。\n\n使用 HTTP 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 Cookie 在 HTTP 等非安全协议中传输，可以设置 Cookie 的 secure 属性为 true。浏览器只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。\n\nJava 中使用`setSecure(booleanflag)`和`getSecure ()`方法来设置、获取 Secure。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-8-cookie-实例)1.8. Cookie 实例\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-8-1-添加-cookie)1.8.1. 添加 Cookie\n\n通过 Servlet 添加 Cookies 包括三个步骤：\n\n1. 创建一个 Cookie 对象：您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。\n2. 设置最大生存周期：您可以使用 `setMaxAge` 方法来指定 cookie 能够保持有效的时间（以秒为单位）。\n3. 发送 Cookie 到 HTTP 响应头：您可以使用 `response.addCookie` 来添加 HTTP 响应头中的 Cookies。\n\nAddCookies.java\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URLEncoder;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/servlet/AddCookies\")\npublic class AddCookies extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public AddCookies() {\n        super();\n    }\n\n    /**\n     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        // 为名字和姓氏创建 Cookie\n        Cookie name = new Cookie(\"name\", URLEncoder.encode(request.getParameter(\"name\"), \"UTF-8\")); // 中文转码\n        Cookie url = new Cookie(\"url\", request.getParameter(\"url\"));\n\n        // 为两个 Cookie 设置过期日期为 24 小时后\n        name.setMaxAge(60 * 60 * 24);\n        url.setMaxAge(60 * 60 * 24);\n\n        // 在响应头中添加两个 Cookie\n        response.addCookie(name);\n        response.addCookie(url);\n\n        // 设置响应内容类型\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        PrintWriter out = response.getWriter();\n        String title = \"设置 Cookie 实例\";\n        String docType = \"<!DOCTYPE html>\\n\";\n        out.println(docType + \"<html>\\n\" + \"<head><title>\" + title + \"</title></head>\\n\"\n                        + \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" + \"<h1 align=\\\"center\\\">\" + title\n                        + \"</h1>\\n\" + \"<ul>\\n\" + \"  <li><b>站点名：</b>：\" + request.getParameter(\"name\")\n                        + \"\\n</li>\" + \"  <li><b>站点 URL：</b>：\" + request.getParameter(\"url\")\n                        + \"\\n</li>\" + \"</ul>\\n\" + \"</body></html>\");\n    }\n\n    /**\n     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n     */\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\naddCookies.jsp\n\n```java\n<%@ page language=\"java\" pageEncoding=\"UTF-8\" %>\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>添加Cookie</title>\n</head>\n<body>\n<form action=/servlet/AddCookies method=\"GET\">\n  站点名 ：<input type=\"text\" name=\"name\">\n  <br/>\n  站点 URL：<input type=\"text\" name=\"url\"/><br>\n  <input type=\"submit\" value=\"提交\"/>\n</form>\n</body>\n</html>\n```\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-8-2-显示-cookie)1.8.2. 显示 Cookie\n\n要读取 Cookies，您需要通过调用 `HttpServletRequest` 的 `getCookies()` 方法创建一个 `javax.servlet.http.Cookie` 对象的数组。然后循环遍历数组，并使用 `getName()` 和 `getValue()` 方法来访问每个 cookie 和关联的值。\n\nReadCookies.java\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URLDecoder;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/servlet/ReadCookies\")\npublic class ReadCookies extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public ReadCookies() {\n        super();\n    }\n\n    /**\n     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        Cookie cookie = null;\n        Cookie[] cookies = null;\n        // 获取与该域相关的 Cookie 的数组\n        cookies = request.getCookies();\n\n        // 设置响应内容类型\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        PrintWriter out = response.getWriter();\n        String title = \"Delete Cookie Example\";\n        String docType = \"<!DOCTYPE html>\\n\";\n        out.println(docType + \"<html>\\n\" + \"<head><title>\" + title + \"</title></head>\\n\"\n                        + \"<body bgcolor=\\\"#f0f0f0\\\">\\n\");\n        if (cookies != null) {\n            out.println(\"<h2>Cookie 名称和值</h2>\");\n            for (int i = 0; i < cookies.length; i++) {\n                cookie = cookies[i];\n                if ((cookie.getName()).compareTo(\"name\") == 0) {\n                    cookie.setMaxAge(0);\n                    response.addCookie(cookie);\n                    out.print(\"已删除的 cookie：\" + cookie.getName() + \"<br/>\");\n                }\n                out.print(\"名称：\" + cookie.getName() + \"，\");\n                out.print(\"值：\" + URLDecoder.decode(cookie.getValue(), \"utf-8\") + \" <br/>\");\n            }\n        } else {\n            out.println(\"<h2 class=\\\"tutheader\\\">No Cookie founds</h2>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n\n    /**\n     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n     */\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_1-8-3-删除-cookie)1.8.3. 删除 Cookie\n\nJava 中并没有提供直接删除 Cookie 的方法，如果想要删除一个 Cookie，直接将这个 Cookie 的有效期设为 0 就可以了。步骤如下：\n\n1. 读取一个现有的 cookie，并把它存储在 Cookie 对象中。\n2. 使用 `setMaxAge()` 方法设置 cookie 的年龄为零，来删除现有的 cookie。\n3. 把这个 cookie 添加到响应头。\n\nDeleteCookies.java\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@WebServlet(\"/servlet/DeleteCookies\")\npublic class DeleteCookies extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public DeleteCookies() {\n        super();\n    }\n\n    /**\n     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n     */\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        Cookie cookie = null;\n        Cookie[] cookies = null;\n        // 获取与该域相关的 Cookie 的数组\n        cookies = request.getCookies();\n\n        // 设置响应内容类型\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        PrintWriter out = response.getWriter();\n        String title = \"删除 Cookie 实例\";\n        String docType = \"<!DOCTYPE html>\\n\";\n        out.println(docType + \"<html>\\n\" + \"<head><title>\" + title + \"</title></head>\\n\"\n                        + \"<body bgcolor=\\\"#f0f0f0\\\">\\n\");\n        if (cookies != null) {\n            out.println(\"<h2>Cookie 名称和值</h2>\");\n            for (int i = 0; i < cookies.length; i++) {\n                cookie = cookies[i];\n                if ((cookie.getName()).compareTo(\"url\") == 0) {\n                    cookie.setMaxAge(0);\n                    response.addCookie(cookie);\n                    out.print(\"已删除的 cookie：\" + cookie.getName() + \"<br/>\");\n                }\n                out.print(\"名称：\" + cookie.getName() + \"，\");\n                out.print(\"值：\" + cookie.getValue() + \" <br/>\");\n            }\n        } else {\n            out.println(\"<h2 class=\\\"tutheader\\\">No Cookie founds</h2>\");\n        }\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n\n    /**\n     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n     */\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        doGet(request, response);\n    }\n\n}\n```\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-session)2. Session\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-1-session-是什么)2.1. Session 是什么\n\n不同于 Cookie 保存在客户端浏览器中，Session 保存在服务器上。\n\n如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。\n\nSession 对应的类为 `javax.servlet.http.HttpSession` 类。Session 对象是在客户第一次请求服务器时创建的。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-2-session-类中的方法)2.2. Session 类中的方法\n\n`javax.servlet.http.HttpSession` 类中的方法：\n\n| **方法**                                            | **功能**                                                     |\n| --------------------------------------------------- | ------------------------------------------------------------ |\n| public Object getAttribute(String name)             | 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。 |\n| public Enumeration getAttributeNames()              | 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。 |\n| public long getCreationTime()                       | 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。 |\n| public String getId()                               | 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。 |\n| public long getLastAccessedTime()                   | 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。 |\n| public int getMaxInactiveInterval()                 | 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。 |\n| public void invalidate()                            | 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。 |\n| public boolean isNew()                              | 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。 |\n| public void removeAttribute(String name)            | 该方法将从该 session 会话移除指定名称的对象。                |\n| public void setAttribute(String name, Object value) | 该方法使用指定的名称绑定一个对象到该 session 会话。          |\n| public void setMaxInactiveInterval(int interval)    | 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。 |\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-3-session-的有效期)2.3. Session 的有效期\n\n由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为防止内存溢出，服务器会把长时间没有活跃的 Session 从内存中删除。\n\nSession 的超时时间为`maxInactiveInterval`属性，可以通过`getMaxInactiveInterval()`、`setMaxInactiveInterval(longinterval)`来读写这个属性。\n\nTomcat 中 Session 的默认超时时间为 20 分钟。可以修改 web.xml 改变 Session 的默认超时时间。\n\n例：\n\n```xml\n<session-config>\n  <session-timeout>60</session-timeout>\n</session-config>\n```\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-4-session-对浏览器的要求)2.4. Session 对浏览器的要求\n\nHTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一客户。因此服务器向客户端浏览器发送一个名为 JESSIONID 的 Cookie，他的值为该 Session 的 id（也就是 HttpSession.getId()的返回值）。Session 依据该 Cookie 来识别是否为同一用户。\n\n该 Cookie 为服务器自动生成的，它的`maxAge`属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-5-url-地址重写)2.5. URL 地址重写\n\nURL 地址重写的原理是将该用户 Session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 Session 的 id。这样即使客户端不支持 Cookie，也可以使用 Session 来记录用户状态。\n\n`HttpServletResponse`类提供了`encodeURL(Stringurl)`实现 URL 地址重写。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-6-session-中禁用-cookie)2.6. Session 中禁用 Cookie\n\n在`META-INF/context.xml`中编辑如下：\n\n```xml\n<Context path=\"/SessionNotes\" cookies=\"true\">\n</Context>\n```\n\n部署后，TOMCAT 便不会自动生成名 JESSIONID 的 Cookie，Session 也不会以 Cookie 为识别标志，而仅仅以重写后的 URL 地址为识别标志了。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-7-session-实例)2.7. Session 实例\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-7-1-session-跟踪)2.7.1. Session 跟踪\n\nSessionTrackServlet.java\n\n```java\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n\n@WebServlet(\"/servlet/SessionTrackServlet\")\npublic class SessionTrackServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n\n    public void doGet(HttpServletRequest request, HttpServletResponse response)\n                    throws ServletException, IOException {\n        // 如果不存在 session 会话，则创建一个 session 对象\n        HttpSession session = request.getSession(true);\n        // 获取 session 创建时间\n        Date createTime = new Date(session.getCreationTime());\n        // 获取该网页的最后一次访问时间\n        Date lastAccessTime = new Date(session.getLastAccessedTime());\n\n        // 设置日期输出的格式\n        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        String title = \"Servlet Session 实例\";\n        Integer visitCount = new Integer(0);\n        String visitCountKey = new String(\"visitCount\");\n        String userIDKey = new String(\"userID\");\n        String userID = new String(\"admin\");\n\n        // 检查网页上是否有新的访问者\n        if (session.isNew()) {\n            session.setAttribute(userIDKey, userID);\n        } else {\n            visitCount = (Integer) session.getAttribute(visitCountKey);\n            visitCount = visitCount + 1;\n            userID = (String) session.getAttribute(userIDKey);\n        }\n        session.setAttribute(visitCountKey, visitCount);\n\n        // 设置响应内容类型\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n\n        String docType = \"<!DOCTYPE html>\\n\";\n        out.println(docType + \"<html>\\n\" + \"<head><title>\" + title + \"</title></head>\\n\"\n                        + \"<body bgcolor=\\\"#f0f0f0\\\">\\n\" + \"<h1 align=\\\"center\\\">\" + title\n                        + \"</h1>\\n\" + \"<h2 align=\\\"center\\\">Session 信息</h2>\\n\"\n                        + \"<table border=\\\"1\\\" align=\\\"center\\\">\\n\" + \"<tr bgcolor=\\\"#949494\\\">\\n\"\n                        + \"  <th>Session 信息</th><th>值</th></tr>\\n\" + \"<tr>\\n\" + \"  <td>id</td>\\n\"\n                        + \"  <td>\" + session.getId() + \"</td></tr>\\n\" + \"<tr>\\n\"\n                        + \"  <td>创建时间</td>\\n\" + \"  <td>\" + df.format(createTime) + \"  </td></tr>\\n\"\n                        + \"<tr>\\n\" + \"  <td>最后访问时间</td>\\n\" + \"  <td>\" + df.format(lastAccessTime)\n                        + \"  </td></tr>\\n\" + \"<tr>\\n\" + \"  <td>用户 ID</td>\\n\" + \"  <td>\" + userID\n                        + \"  </td></tr>\\n\" + \"<tr>\\n\" + \"  <td>访问统计：</td>\\n\" + \"  <td>\" + visitCount\n                        + \"</td></tr>\\n\" + \"</table>\\n\" + \"</body></html>\");\n    }\n}\n```\n\nweb.xml\n\n```xml\n<servlet>\n  <servlet-name>SessionTrackServlet</servlet-name>\n  <servlet-class>SessionTrackServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n  <servlet-name>SessionTrackServlet</servlet-name>\n  <url-pattern>/servlet/SessionTrackServlet</url-pattern>\n</servlet-mapping>\n```\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_2-7-2-删除-session-会话数据)2.7.2. 删除 Session 会话数据\n\n当您完成了一个用户的 session 会话数据，您有以下几种选择：\n\n**移除一个特定的属性：**您可以调用 `removeAttribute(String name)` 方法来删除与特定的键相关联的值。\n\n**删除整个 session 会话：**您可以调用 `invalidate()` 方法来丢弃整个 session 会话。\n\n**设置 session 会话过期时间：**您可以调用 `setMaxInactiveInterval(int interval)` 方法来单独设置 session 会话超时。\n\n**注销用户：**如果使用的是支持 servlet 2.4 的服务器，您可以调用 `logout` 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。\n\n**web.xml 配置：**如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：\n\n```xml\n<session-config>\n  <session-timeout>15</session-timeout>\n</session-config>\n```\n\n上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。\n\n在一个 Servlet 中的 `getMaxInactiveInterval()` 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么`getMaxInactiveInterval()` 会返回 900。\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-cookie-vs-session)3. Cookie vs Session\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-1-存取方式)3.1. 存取方式\n\nCookie 只能保存`ASCII`字符串，如果需要存取 Unicode 字符或二进制数据，需要进行`UTF-8`、`GBK`或`BASE64`等方式的编码。\n\nSession 可以存取任何类型的数据，甚至是任何 Java 类。可以将 Session 看成是一个 Java 容器类。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-2-隐私安全)3.2. 隐私安全\n\nCookie 存于客户端浏览器，一些客户端的程序可能会窥探、复制或修改 Cookie 内容。\n\nSession 存于服务器，对客户端是透明的，不存在敏感信息泄露的危险。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-3-有效期)3.3. 有效期\n\n使用 Cookie 可以保证长时间登录有效，只要设置 Cookie 的`maxAge`属性为一个很大的数字。\n\n而 Session 虽然理论上也可以通过设置很大的数值来保持长时间登录有效，但是，由于 Session 依赖于名为`JESSIONID`的 Cookie，而 Cookie `JESSIONID`的`maxAge`默认为-1，只要关闭了浏览器该 Session 就会失效，因此，Session 不能实现信息永久有效的效果。使用 URL 地址重写也不能实现。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-4-服务器的开销)3.4. 服务器的开销\n\n由于 Session 是保存在服务器的，每个用户都会产生一个 Session，如果并发访问的用户非常多，会产生很多的 Session，消耗大量的内存。\n\n而 Cookie 由于保存在客户端浏览器上，所以不占用服务器资源。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-5-浏览器的支持)3.5. 浏览器的支持\n\nCookie 需要浏览器支持才能使用。\n\n如果浏览器不支持 Cookie，需要使用 Session 以及 URL 地址重写。\n\n需要注意的事所有的用到 Session 程序的 URL 都要使用`response.encodeURL(StringURL)` 或`response.encodeRediretURL(String URL)`进行 URL 地址重写，否则导致 Session 会话跟踪失效。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-cookie-sesion.html#_3-6-跨域名)3.6. 跨域名\n\n- Cookie 支持跨域名。\n- Session 不支持跨域名。', '2022-02-17 14:51:24', '2022-02-17 14:51:24', 0, 22001, 1, 1, 1);
INSERT INTO `blog` VALUES (13, 'JavaEE 之 Filter 和 Listener', 'http://up.deskcity.org/pic_360/202010/sl/mjq5et0uktz2742.jpg', 'Filter 和 Listener', '# JavaEE 之 Filter 和 Listener\n\n引入了 Servlet 规范后，你不需要关心 Socket 网络通信、不需要关心 HTTP 协议，也不需要关心你的业务类是如何被实例化和调用的，因为这些都被 Servlet 规范标准化了，你只要关心怎么实现的你的业务逻辑。这对于程序员来说是件好事，但也有不方便的一面。所谓规范就是说大家都要遵守，就会千篇一律，但是如果这个规范不能满足你的业务的个性化需求，就有问题了，因此设计一个规范或者一个中间件，要充分考虑到可扩展性。Servlet 规范提供了两种扩展机制：**Filter**和**Listener**。\n\n- \\1. Filter\n  - [1.1. 过滤器方法](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#11-过滤器方法)\n  - [1.2. 过滤器配置](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#12-过滤器配置)\n- \\2. Listener\n  - [2.1. 监听器的分类](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#21-监听器的分类)\n  - [2.2. 监听对象的创建和销毁](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#22-监听对象的创建和销毁)\n  - [2.3. 监听对象的属性变化](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#23-监听对象的属性变化)\n  - [2.4. 监听 Session 内的对象](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#24-监听-session-内的对象)\n- [3. Filter 和 Listener](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#3-filter-和-listener)\n- [4. 示例代码](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#4-示例代码)\n- [5. 参考资料](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#5-参考资料)\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_1-filter)1. Filter\n\n**Filter 是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理**。\n\nFilter 提供了过滤链（Filter Chain）的概念，一个过滤链包括多个 Filter。客户端请求 request 在抵达 Servlet 之前会经过过滤链的所有 Filter，服务器响应 response 从 Servlet 抵达客户端浏览器之前也会经过过滤链的所有 FIlter。\n\n![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/1559054413341.png)\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_1-1-过滤器方法)1.1. 过滤器方法\n\nFilter 接口有三个方法：\n\n- `init`：初始化 `Filter`\n- `destroy`：销毁 `Filter`\n- `doFilter`：将请求传给下个 `Filter` 或 `Servlet`\n\n`init` 和 `destroy` 方法只会被调用一次；`doFilter` 每次有客户端请求都会被调用一次。\n\n```java\npublic interface Filter {\n\n	/**\n	 * web 程序启动时调用此方法, 用于初始化该 Filter\n	 * @param config\n	 *            可以从该参数中获取初始化参数以及ServletContext信息等\n	 * @throws ServletException\n	 */\n	public void init(FilterConfig config) throws ServletException;\n\n	/**\n	 * 客户请求服务器时会经过\n	 *\n	 * @param request\n	 *            客户请求\n	 * @param response\n	 *            服务器响应\n	 * @param chain\n	 *            过滤链, 通过 chain.doFilter(request, response) 将请求传给下个 Filter 或\n	 *            Servlet\n	 * @throws ServletException\n	 * @throws IOException\n	 */\n	public void doFilter(ServletRequest request, ServletResponse response,\n			FilterChain chain) throws ServletException, IOException;\n\n	/**\n	 * web 程序关闭时调用此方法, 用于销毁一些资源\n	 */\n	public void destroy();\n\n}\n```\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_1-2-过滤器配置)1.2. 过滤器配置\n\n`Filter` 需要配置在 `web.xml` 中才能生效。一个 `Filter` 需要配置 `<filter>` 与 `<filter-mapping>` 标签。\n\n- `<filter>` 配置 Filter 名称，实现类以及初始化参数。\n\n- `<filter-mapping>` 配置什么规则下使用该 Filter。\n\n- `<filter>` 的 filterName 与 `<filter-mapping>` 的 filterName 必须匹配。\n\n- `<url-pattern>` 配置 URL 的规则，可以配置多个，可以使用通配符（`*`）。\n\n- ```\n  <dispatcher>\n  ```\n\n   \n\n  配置到达 Servlet 的方式，有 4 种取值：REQUEST、FORWARD、INCLUDE、ERROR。可以同时配置多个\n\n   \n\n  ```\n  <dispatcher>\n  ```\n\n  。如果没有配置任何\n\n   \n\n  ```\n  <dispatcher>\n  ```\n\n  ，默认为 REQUEST。\n\n  - REQUEST - 表示仅当直接请求 Servlet 时才生效。\n  - FORWARD - 表示仅当某 Servlet 通过 FORWARD 到该 Servlet 时才生效。\n  - INCLUDE - JSP 中可以通过 `<jsp:include>` 请求某 Servlet。仅在这种情况表有效。\n  - ERROR - JSP 中可以通过 `<%@ page errorPage=\"error.jsp\" %>` 指定错误处理页面。仅在这种情况表有效。\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-listener)2. Listener\n\n监听器（`Listener`）用于监听 web 应用程序中的`ServletContext`, `HttpSession`和 `ServletRequest`等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。\n\n使用 `Listener` 不需要关注该类事件时怎样触发或者怎么调用相应的 `Listener`，只要记住该类事件触发时一定会调用相应的 `Listener`，遵循 Servlet 规范的服务器会自动完成相应工作。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-1-监听器的分类)2.1. 监听器的分类\n\n在 Servlet 规范中定义了多种类型的监听器，它们用于监听的事件源分别为`ServletContext`，`HttpSession`和`ServletRequest`这三个域对象 Servlet 规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：\n\n1. 监听域对象自身的创建和销毁的事件监听器。\n2. 监听域对象中的属性的增加和删除的事件监听器。\n3. 监听绑定到 HttpSession 域中的某个对象的状态的事件监听器。\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-2-监听对象的创建和销毁)2.2. 监听对象的创建和销毁\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-2-1-httpsessionlistener)2.2.1. HttpSessionListener\n\n**`HttpSessionListener` 接口用于监听 `HttpSession` 对象的创建和销毁。**\n\n- 创建一个 `Session` 时，激发 `sessionCreated (HttpSessionEvent se)` 方法\n- 销毁一个 `Session` 时，激发 `sessionDestroyed (HttpSessionEvent se)` 方法。\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-2-2-servletcontextlistener)2.2.2. ServletContextListener\n\n**`ServletContextListener` 接口用于监听 `ServletContext` 对象的创建和销毁事件。**\n\n实现了 `ServletContextListener` 接口的类都可以对 `ServletContext` 对象的创建和销毁进行监听。\n\n- 当 `ServletContext` 对象被创建时，激发 `contextInitialized (ServletContextEvent sce)` 方法。\n- 当 `ServletContext` 对象被销毁时，激发 `contextDestroyed(ServletContextEvent sce)` 方法。\n\n`ServletContext` 域对象创建和销毁时机：\n\n- 创建：服务器启动针对每一个 Web 应用创建 `ServletContext`\n- 销毁：服务器关闭前先关闭代表每一个 web 应用的 `ServletContext`\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-2-3-servletrequestlistener)2.2.3. ServletRequestListener\n\n**`ServletRequestListener` 接口用于监听 `ServletRequest` 对象的创建和销毁。**\n\n- `Request` 对象被创建时，监听器的 `requestInitialized(ServletRequestEvent sre)` 方法将会被调用\n- `Request` 对象被销毁时，监听器的 `requestDestroyed(ServletRequestEvent sre)` 方法将会被调用\n\n`ServletRequest` 域对象创建和销毁时机：\n\n- 创建：用户每一次访问都会创建 request 对象\n- 销毁：当前访问结束，request 对象就会销毁\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-3-监听对象的属性变化)2.3. 监听对象的属性变化\n\n域对象中属性的变更的事件监听器就是用来监听 `ServletContext`、`HttpSession`、`HttpServletRequest` 这三个对象中的属性变更信息事件的监听器。 这三个监听器接口分别是 `ServletContextAttributeListener`、`HttpSessionAttributeListener` `和 ServletRequestAttributeListener`，这三个接口中都定义了三个方法来处理被监听对象中的属性的增加，删除和替换的事件，同一个事件在这三个接口中对应的方法名称完全相同，只是接受的参数类型不同。\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-3-1-attributeadded-方法)2.3.1. attributeAdded 方法\n\n当向被监听对象中增加一个属性时，web 容器就调用事件监听器的 `attributeAdded` 方法进行响应，这个方法接收一个事件类型的参数，监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象 各个域属性监听器中的完整语法定义为：\n\n```java\npublic void attributeAdded(ServletContextAttributeEvent scae)\npublic void attributeReplaced(HttpSessionBindingEvent hsbe)\npublic void attributeRmoved(ServletRequestAttributeEvent srae)\n```\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-3-2-attributeremoved-方法)2.3.2. attributeRemoved 方法\n\n当删除被监听对象中的一个属性时，web 容器调用事件监听器的 `attributeRemoved` 方法进行响应 各个域属性监听器中的完整语法定义为：\n\n```java\npublic void attributeRemoved(ServletContextAttributeEvent scae)\npublic void attributeRemoved(HttpSessionBindingEvent hsbe)\npublic void attributeRemoved(ServletRequestAttributeEvent srae)\n```\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-3-3-attributereplaced-方法)2.3.3. attributeReplaced 方法\n\n当监听器的域对象中的某个属性被替换时，web 容器调用事件监听器的 `attributeReplaced` 方法进行响应 各个域属性监听器中的完整语法定义为：\n\n```java\npublic void attributeReplaced(ServletContextAttributeEvent scae)\npublic void attributeReplaced(HttpSessionBindingEvent hsbe)\npublic void attributeReplaced(ServletRequestAttributeEvent srae)\n```\n\n### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-4-监听-session-内的对象)2.4. 监听 Session 内的对象\n\n保存在 Session 域中的对象可以有多种状态：\n\n- 绑定（`session.setAttribute(\"bean\",Object)`）到 `Session` 中；\n- 从 `Session` 域中解除绑定（`session.removeAttribute(\"bean\")`）；\n- 随 `Session` 对象持久化到一个存储设备中；\n- 随 `Session` 对象从一个存储设备中恢复。\n\nServlet 规范中定义了两个特殊的监听器接口 `HttpSessionBindingListener` 和`HttpSessionActivationListener` 来帮助 JavaBean 对象了解自己在 Session 域中的这些状态。\n\n实现这两个接口的类不需要 `web.xml` 文件中进行注册。\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-4-1-httpsessionbindinglistener)2.4.1. HttpSessionBindingListener\n\n`HttpSessionBindingListener` 接口的 JavaBean 对象可以感知自己被绑定或解绑定到 `Session` 中的事件。\n\n- 当对象被绑定到 `HttpSession` 对象中时，web 服务器调用该对象的 `valueBound(HttpSessionBindingEvent event)` 方法。\n- 当对象从 `HttpSession` 对象中解除绑定时，web 服务器调用该对象的 `valueUnbound(HttpSessionBindingEvent event)` 方法。\n\n#### [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_2-4-2-httpsessionactivationlistener)2.4.2. HttpSessionActivationListener\n\n实现了 `HttpSessionActivationListener` 接口的 JavaBean 对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。\n\n- 当绑定到 `HttpSession` 对象中的 JavaBean 对象将要随 `HttpSession` 对象被序列化之前，web 服务器调用该 JavaBean 对象的 `sessionWillPassivate(HttpSessionEvent event)` 方法。这样 JavaBean 对象就可以知道自己将要和 `HttpSession` 对象一起被序列化到硬盘中.\n- 当绑定到 `HttpSession` 对象中的 JavaBean 对象将要随 `HttpSession` 对象被反序列化之后，web 服务器调用该 JavaBean 对象的 `sessionDidActive(HttpSessionEvent event)` 方法。这样 JavaBean 对象就可以知道自己将要和 `HttpSession` 对象一起被反序列化回到内存中\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_3-filter-和-listener)3. Filter 和 Listener\n\nFilter 和 Listener 的本质区别：\n\n- **Filter 是干预过程的**，它是过程的一部分，是基于过程行为的。\n- **Listener 是基于状态的**，任何行为改变同一个状态，触发的事件是一致的。\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_4-示例代码)4. 示例代码\n\n- `Filter` 的示例源码：[源码(opens new window)](https://github.com/dunwu/javatech/tree/master/codes/javaee-tutorial/javaee-tutorial-filter)\n- `Listener` 的示例源码：[源码(opens new window)](https://github.com/dunwu/javatech/tree/master/codes/javaee-tutorial/javaee-tutorial-listener)\n\n## [#](https://dunwu.github.io/java-tutorial/javaee/javaee-filter-listener.html#_5-参考资料)5. 参考资料\n\n- [深入拆解 Tomcat & Jetty(opens new window)](https://time.geekbang.org/column/intro/100027701)\n- [Java Web 整合开发王者归来](', '2022-02-17 14:53:57', '2022-02-17 14:53:57', 0, 9569, 1, 1, 1);
INSERT INTO `blog` VALUES (14, 'Java面试200题', 'http://up.deskcity.org/pic_360/202010/sl/bv44y0retsa0306.jpg', 'Java面试题', '# JavaSE(88)\n\n## 基础语法(9)\n\n### Q1:简单说说Java有哪些数据类型\n\n分为基本数据类型和引用数据类型：\n\n基本数据类型分为四类八种：分别是\n\n整型：byte,short,int,long\n\n浮点型：float,double\n\n字符型：char\n\n布尔型：boolean\n\n\n\n引用类型包括：类、接口和数组等。\n\n\n\n### Q2：float number=3.4;有没有问题？为什么？\n\n有问题，因为3.4是双精度数(double)，将双精度数赋值给浮点型属于向下转型，可能会造成精度损失，所以必须进行强制类型转换。\n\n正确的写法：`float number=(float)3.4;`、`float number=3.4F;`\n\n### \n\n### Q3:字符串拼接的方式和效率？\n\n①使用`+`直接拼接，String是final对象，不会被修改，每次使用`+`进行拼接都会创建一个新的对象，而不是改变原来的对象，效率低，是线程安全的。\n\n②使用StringBuffer可变字符串，效率较高，是线程安全的(StringBuffer的方法使用了`synchronized`关键字修饰)。\n\n③使用StringBuilder可变字符串，效率最高，但是线程不安全。\n\n\n\n### Q4：简述final、finally和finalize区别\n\n①final可以修饰**类、变量、方法**，被final修饰的类不可继承，被final修饰的方法不可重写，被final修饰的变量引用不可更改，引用的内容可更改。\n\n②finally用于try-catch代码块中，无论是否发生异常，最后都将执行，作用是释放资源。\n\n③finalize是Object类的方法，在对象被垃圾回收之前将调用一次，一般用于资源的释放。\n\n\n\n### Q5：==和equals有什么区别？equals和hashCode有什么联系？\n\n①如果是引用类型，`==`比较的是两个对象的引用是否完全相同，如果是基本类型，比较的是两个基本类型的数值是否相同。\n\n②如果没有重写的话，equals默认按照`==`进行比较，如果重写了equals()方法，则按照对应的规则进行比较。\n\n③两个对象如果相等，那么它们的hashCode值必须相等，但两个对象的hashCode值相等时，它们不一定相同。\n\n\n\n### Q6：Array和ArrayList的区别？\n\n①Array长度在定义之后就不能够改变了，而ArrayList的长度是可变的，可以自动扩容。\n\n②Array只能存储相同类型的数据，ArrayList可以存储不同类型的数据。\n\n③ArrayList提供更多操作数据的方法。\n\n\n\n### Q7：&和&&的区别？\n\n①&具有按位与和逻辑与两个功能。\n\n②&&作为逻辑与**具有短路**的特点，当前面表达式为false的时候就不会进行后面表达式的判断，可以用来避免空指针异常。\n\n\n\n### Q8：简述JDK8的新特性\n\n①接口中可以添加`default`修饰的非抽象方法，可以有方法体和内容。\n\n②可以使用Lambda表达式，减少代码冗余。\n\n③函数式接口，使用`@FunctionalInterface`注解标明，该接口有且仅有一个抽象方法。\n\n④方法引用，可以直接引用已有Java类或对象的方法或构造器，进一步简化Lambda表达式。\n\n⑤stream流，用于解决已有集合/数组类库的弊端，简化其操作，有`foreach`遍历，`filter`过滤,`map`映射，`concat`合并等功能。\n\n⑥增加日期相关的API。\n\n\n\n### Q9:Stream流了解吗？\n\n①Stream流时JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。\n\n②stream流的获取：\n\n​		集合：直接调用`stream()`方法获取；\n\n​		数组：使用静态方法`Stream.of()/Arrays.stream()`获取。\n\n③常用方法：\n\n- `forEach()`遍历\n- `count()`统计个数\n- `filter()`按条件过滤\n- `limit()`取前面n个元素\n- `skip()`跳过前面n个元素\n- `map()`映射加工\n- `concat()`合并stream流\n\n④终结方法：`foreach/count`调用终结方法后流不能继续使用；非终结方法：每次调用完返回一个新的Stream对象，可以继续使用，支持链式编程。\n\n⑤收集stream流：把流转为Set集合`collect(Collections.toSet())`;把流转为List集合`collect(Collections.toList())`;把流转为Collection集合`collect(Collections.toCollection())`；把流转为数组`toArray()`。\n\n\n\n## 面向对象(10)\n\n### Q1：简述面向对象的特性\n\n①封装：建议成员变量私有，然后提供公有的`getter/setter`方法来获取值/赋值，封装的核心思想是**合理隐藏，合理暴露**，可以提高安全性，提高代码的组件化。\n\n②继承：一种子类到父类的关系，是“is a”的关系，可以提高代码的复用性，相同代码可写到父类，子类功能更加强大，不仅得到了父类的功能，还有自己的功能。\n\n③多态：同一个类型的对象执行相同的行为，在不同状态下表现出不同的特征。多态可以降低类之间的耦合度，**右边对象**可以实现组件化切换，业务功能随之改变，便于扩展和维护。\n\n\n\n### Q2：类和对象有什么区别？\n\n类是一个抽象的概念，是具有相同特征的事物的描述，是对象的模板。\n\n对象是一个个具体的存在，是类的实例。\n\n\n\n### Q3：列举Object类的方法\n\n①`equals(Object obj)`:判断其他对象是否与当前对象相等。\n\n②`toString()`:打印当前对象的字符串表示。\n\n③`wait()`:导致当前线程等待，等待其他线程唤醒，会释放锁。\n\n④`notify()/notifyAll()`:随机唤醒一个/全部线程。\n\n⑤`hashCode()`：返回当前对象的hashCode值。\n\n⑥`finalize()`:当垃圾回收器要回收对象前调用。\n\n⑦`clone()`:创建并返回对象的一个副本。\n\n\n\n### Q4：方法重载和方法重写的区别？\n\n①方法重载是同一个类中**具有不同参数列表的同名方法**（无返回值类型），方法重写是子类中具有和父类相同参数列表的同名方法，会覆盖父类原有的方法。\n\n②重载的返回值类型和权限修饰符，异常抛出类型没有要求，重写方法的返回值类型小于等于父类被重写方法的返回值类型，修饰符权限大于等于父类被重写方法权限修饰符，抛出的异常小于等于父类被重写方法抛出的异常类型。\n\n\n\n方法重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n\n重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重载对返回类型没有特殊的要求，不能根据返回类型进行区分。\n\n重写发生在子类和父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏替换原则）。\n\n- 发生方法重写的两个方法返回值、方法名、参数列表必须完全一致（子类重写父类的方法）\n- 子类抛出的异常下不能超过父类相应方法抛出的异常（子类异常不能大于父类异常）\n- 子类方法的访问级别不能低于父类相应方法的访问级别（子类访问级别不能低于父类访问级别）\n\n\n\n### 重写equals的几个原则\n\n1. 对称性，A.equals(B)==true，B.equals(A)也一定为true\n2. 反射性，A.equals(A)已定位true\n3. 类推性，`A.equals(B)==true，B.equals(C)==true`，则A.equals(C)==ture\n4. 一致性，A.equals(B)==true时，不管调用多少次都应该返回true，不会改变\n5. 非空性，A.equals(null)一定为false\n6. 如果有hashcode的地方，一定重写hashcode\n\n\n\n\n\n### Q5:接口和抽象类的区别？\n\n①接口中只能定义`public static final`修饰的常量，抽象类中可以定义普通变量。\n\n②接口和抽象类都不能实例化，但**接口没有构造器，抽象类有构造器**。\n\n③接口可以多实现，抽象类只能单继承。\n\n④接口在JDK1.8之前只能定义`public abstract`修饰的方法，JDK1.8开始可以定义默认方法和静态方法，JDK1.9开始可以定义私有方法，抽象类中的方法没有限制。\n\n- 接口只有定义，其方法不能在接口中实现，只有实现接口的类才能实现接口中的方法，而抽象类中方法可以在抽象类中实现\n- 成员变量：接口中的成员变量默认的修饰符为public static final的\n- 抽象类可以有构造方法，静态方法，静态代码块，接口不能定义构造方法，静态方法，静态代码块\n- 实现抽象类的关键字是extends，实现接口的关键字是implements，一个类可以实现多个接口，但是只能继承一个抽象类\n- **抽象类是对事物的抽象，即对类抽象；接口是对行为的抽象**\n\n\n\n### Q6:什么时候应该使用接口，什么时候应该使用抽象类？\n\n①如果知道某个类应该成为基类，那么第一选择应该让它称为一个接口，**只有在必须要有方法定义和成员变量的时候**，才应该选择**抽象类**。\n\n②在接口和抽象类的选择上，必须遵循一个原则：*行为模型应该总是通过接口而不是抽象类定义。*通过抽象类建立行为模型会出现的问题：如果有一个抽象类Mobile，有两个继承它的类Mobile1和Mobile2，分别有自己的功能1和功能2，如果出现一个既有功能1和功能2的新产品需求，由于Java不允许多继承就出现了问题，而如果是接口的话只需要实现两个接口即可。\n\n\n\n### Q7：内部类有什么作用？有哪些分类？\n\n①内部类有更好的封装性，有更多的权限修饰符，封装性可以得到更多的控制。\n\n②静态内部类：**由static修饰，属于类本身，只加载一次**。类可以定义的成分静态内部类都可以定义，可以访问外部类的静态变量和方法，通过`new 外部类.静态内部类构造器`来创建对象。\n\n③成员内部类：属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可以访问外部类的所有内容，通过`new 外部类构造器.new 成员内部类构造器`来创建对象。\n\n④局部内部类：定义在方法、构造器、代码块、循环中。只能定义实例成员变量和实例方法，作用范围仅在局部代码块中。\n\n⑤匿名内部类：没有名字的局部内部类，可以简化代码，匿名内部类会立即创建一个匿名内部类的对象返回，返回类型相当于当前new的类的子类类型。\n\n```java\npublic static void main(String[] args){\n    new Outer.Inner1();  // 静态内部类\n    new Outer.new Inner();   // 成员内部类\n}\n\nClass Outer{\n    static class Inner1(){\n        \n    }\n    \n    class Inner {\n        \n    }\n}\n```\n\n\n\n### Q8：泛型和泛型擦除是什么？\n\n①泛型的本质是参数化类型，泛型提供了编译时类型的安全检测机制，该机制允许程序在编译时检测非法的类型。\n\n②在编译阶段采用泛型时加上的类型参数，会被编译器在编译时去掉，这个过程就被称为**类型擦除**，因此泛型主要用于**编译阶段**，在编译后生成的Java字节码文件中不包含泛型中的类型信息。\n\n\n\n### Q9：泛型标记的规范了解吗？\n\n①`E`:值Element，在集合中使用，表示在集合中存放的元素。\n\n②`T`:指Type，表示Java类，包括基本的类以及自定义类\n\n③`K`:指Key，表示键，例如Map集合中的Key。\n\n④`V`:指Value，表示值，例如Map集合中的Value。\n\n⑤`N`:指Number，表示数值类型。\n\n⑥`?`:表示不确定的Java类型。\n\n\n\n### Q10：泛型限定是什么？\n\n①类型通配符使用`?`表示所有具体的类型参数，在使用泛型的时候，如果希望将类的继承关系加入泛型应用中就需要对泛型做限定，具体的泛型限定有对泛型上线的限定以及对泛型下限的限定。\n\n②对泛型上限的限定使用`<? extends T>`,它表示该通配符所代表的类型是**T类的子类型**或**T接口的子接口**。\n\n③对泛型下限的限定使用`<? super T>`,它表示该通配符所代表的类型是**T类的父类型**或**T接口的父接口**。\n\n\n\n## 异常(2)\n\n### Q1:异常有哪些分类？出现的原因是什么？\n\n①Throwable是所有错误和异常的父类，Throwable分为Error和Exception。\n\n②Error值Java程序运行错误，出现Error通常是因为内部错误或者资源耗尽，Error不能再运行过程中被动态代理，如果程序运行中出现Error，系统只能记录错误的原因和安全终止。\n\n③Exception是指Java程序运行异常，即运行中发生了不期望的情况，分为**RuntimeException**和**CheckedException**。\n\n运行时异常指的是Java虚拟机正常运行期间抛出的异常，可以被捕获并处理，例如**空指针异常、数组越界等**\n\n检查异常指编译阶段强制要求捕获并处理的异常，例如IO异常，SQL异常。\n\n\n\n### Q2：有哪些异常处理方式？\n\n①抛出异常：遇到异常时不进行处理，而是将异常抛给调用者，由调用者根据情况进行处理。抛出异常分为两种形式：\n\n一种是**throws**:作用在方法上；\n\n一种是**throw**：作用在方法内；\n\n②使用try/catch进行异常的捕获处理，try中发生的异常被catch代码块捕获，根据情况进行处理，如果有finally代码块无论是否发生异常都会执行，一般用于释放资源，JDK1.7开始可以将资源定义在try代码块中自动释放以减少代码。\n\n\n\n## 集合(10)\n\n### Q1:简述一下集合主要有哪些类和接口，各自有什么特定？\n\n①主要有两个接口：**Collection和Map**，其中Collection有包括**List、Set和Queue**。\n\n②List是有序的，主要包括**ArrayList、LinkedList和Vector**，ArrayList底层通过数组实现，线程不安全，Vector是线程安全的ArrayList，但是效率较低。LinkedList底层通过双向链表实现，与ArrayList相比增删快，查询慢。\n\n③Set是唯一无序的，主要包括**HashSet、LinkedHashSet和TreeSet**。HashSet底层其实就是HashMap，利用key来保证唯一性。LinkedHashSet可以按照key的操作顺序排序，TreeSet支持按照默认或者指定的排序规则排序。\n\n④Queue是队列结构，主要有ArrayBlockingQueue(基于数组的阻塞队列)、LinkedBlockingQueue(基于链表的阻塞队列)等。\n\n⑤Map以key-value键值对的形式存储元素，主要包括HashMap、LinkedHashMap和TreeMap。HashMap底层通过数组+链表/红黑树实现，LinkedHashMap可以按照key的操作顺序对集合排序 ，TreeMap可以按照默认或指定的排序规则对集合排序。\n\n\n\n### Q2：HashMap是线程安全的吗？\n\n①HashMap是线程不安全的，可以使用**ConcurrentHashMap**保证线程安全。\n\n②ConcurrentHashMap基于减小锁粒度的思想，通过使用分段锁来实现线程安全，内部细分为很多Segment数据段，默认情况为16个，对每个Segment的数据都单独进行加锁操作，Segment的个数为锁的并发度。ConcurrentHashMap由Segment数组和HashEntry数组组成的，Segment继承了可重入锁，HashEntry用来存储键值对数据。\n\n③Segment的结构和HashMap类似，是数组和链表结构，每个Segment里面都包含一个HashEntry数组，每个HashEntry都是一个链表结构的数据要对其进行修改必须先获得对应的Segment锁。\n\n④多线程下只要加入的数据hashCode映射的数据段不一样就可以做到并行的线程安全。\n\n\n\n### HashMap和HashTable的区别\n\n- HashMap是线程不安全的，HashTable是线程安全的\n- HashMap允许存储null值，HashTable不允许\n- 使用的hashCode不同，HashMap是重新计算的，重写的HashCode方法，HashTable则直接使用对象的HashCode\n- 扩容机制不同，HashMap初始容量是16，扩容为2倍，HashTable初始容量是11，扩容方式为$*2+1$\n\n\n\n\n\n### Q3:List、Set、Map有什么区别？\n\n①List是有序、可重复、有索引的集合，继承了Collection集合全部功能，除了Collection的三种遍历方式外，可用索引遍历。\n\n②Set是无序、不可重复的集合，Set的实现类LinkedHashSet和TreeSet是有序的，LinkedHashSet可以按照元素插入的顺序排序，也可以按照元素操作的时间排序，TreeSet可以按照默认的比较规则或则自定义的比较规则排序。\n\n③Map是无序、以key-value的键值对形式存储元素的集合，键不可重复，值无要求，重复的键对应的值胡覆盖之前的值。\n\n\n\n### Q4:HashSet是如何去重的？\n\n①对于基本类型的包装类，可以直接按值进行比较。\n\n②对于引用数据类型，会先比较hashCode()返回值是否相同，如果不同则代表不是同一个对象，如果相同则继续比较equals()方法返回值是否相同，都相同说明是同一个对象。\n\n③如果希望内容相同的对象代表相同对象，那么除了重写equals(0方法还要重写hashCode()方法，因为内容相同的对象hashCode(0值不一定相同，因为只有hashCode()和equals()都相同才说明是同一个对象。\n\n\n\n### Q5:HashMap和HashSet的底层是怎么实现的？\n\n①在JDK1.8之前，HashMap的底层是数组加链表实现。数组中每个元素都是一个单链表，链表中的每个元素都是Entry的实现类Node的一个实例，Node包括4个属性：key、value、hash值和用于指向单链表下一个元素的next。\n\n②HashMap在查找数据时，根据hash值可以快速定位到数组的具体下标，然后对链表进行遍历查找数据的时间复杂度为O(n)。JDK1.8起对HashMap进行了优化，底层改为数组+链表或红黑树，当链表中的元素超过了8个之后，HashMap会将链表结构转换为红黑树以提高查询效率，时间复杂度为O(logn)。\n\n③HashSet的底层是基于HashMap实现的，HashSet中的元素知识存放在底层HashMap的key上，而value使用了一个static final的Object对象标识。因此HashSet的实现比较简单，相关操作基本上都是直接调用底层HashMap的相关方法来完成的。\n\n\n\n### Q6:Collection和Collections有什么区别？\n\n①Collection是一个集合接口，它包括List有序集合、Set无序集合、Queue队列等。\n\n②Collections则是Collection的一个工具类，为Collection类型的对象提供了很多方便的方法，例如addAll()可以直接对Collection集合批量添加元素，shuffle可以随机打乱List集合的元素顺序，sort可以对List集合进行默认或者按比较器排序。\n\n\n\n### Q7：迭代器是什么？\n\n①迭代器实现了Iterator接口，是用于遍历Collection集合元素的一个指针。\n\n②主要有三个方法：\n\n- 通过iterator()获得集合的迭代器；\n- 通过hasNext()判断集合当中是否还有元素，如果有返回true，没有则返回false，初始时迭代器位于第一个元素之前；\n- 通过next()获取集合的下一个元素，并向后移动一个元素的单位。\n\n\n\n### Q8:在使用foreach循环遍历集合时能否添加或删除元素？\n\n使用foreach循环遍历元素集合时不能修改或删除元素，通过java -c查看字节码可以发现foreach循环实际上是用iterator迭代器实现的，如果进行添加或删除元素会抛出ConcurrentModificationException异常，因为添加或删除元素会改变modCount的值，modCount是集合类的一个成员变量，代表集合的修改次数，当modCount的值和预期的exceptedModCount值不一致时就会抛出ConcurrentModificationException异常。\n\n\n\n### Q9:Queue接口中的add()/offer()、remove()/poll()、element()/peek()方法有什么区别？\n\n①add()和offer()都是向队列尾插入一个元素，区别是当超出队列界限时，add()方法会抛出异常，而offer()会返回false。\n\n②remove()和poll()都是从队列头部移除一个元素并返回，区别是队列为空时remove()方法会抛出异常，poll()方法则是返回null值。\n\n③element()和peek()都是用于查询队列头部的元素，区别是队列为空时，element()抛出一个异常，而peek()返回null。\n\n\n\n### Q10:有哪些线程安全的集合类？\n\n①Vector，是线程安全的ArrayList，底层用数组实现，通过synchronized修饰方法保证线程安全。\n\n②HashTable,是线程安全的HashMap，线程安全的HashMap，通过分段锁实现线程安全，性能较好。\n\n③ConcurrentHashMap，线程安全的HashMap，通过分段锁实现线程安全，性能较好。\n\n\n\n### 多线程(34)\n\n### Q1:创建线程有哪些实现方式？分别有什么优缺点？\n\n①继承Thread类，重写run()方法即可。优点是编程简单，缺点是不能继承其他类，功能单一。\n\n②实现Runnable接口，重写run()方法，并将该实现类作为参数传入Thread构造器。优点是可以继承其他类，避免了单继承的局限性；适合多个相同程序代码的线程共享的一个资源(同一个线程任务对象可被包装成多个线程对象)，实现解耦操作，代码和线程独立。缺点是实现相对复杂。\n\n③实现Callable接口，重写call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。优点是相比方式二可以获得返回值，缺点是实现复杂。\n\n④可以通过线程池创建。\n\n\n\n### Q2:线程有哪些状态？\n\n①new：用new操作来创建一个新线程，此时程序还未开始运行线程中的代码。\n\n②runnable：调用start()方法进入可运行状态。\n\n③blocked：阻塞状态，内部锁（不是juc中的锁）获取失败时进入阻塞状态。\n\n④waiting：等待其他线程唤醒是进入等待状态。\n\n⑤time wating：计时等待，带超时参数的方法，例如Sleep(long time)\n\n⑥terminated：终止状态，线程正常运行完毕或未被捕获异常终止。\n\n\n\n\n\n## Java IO\n\n### IO多路复用的底层原理\n\nIO多路复用使用两个系统调用(select/poll/epoll和recvfrom)，blocking IO只调用recvfrom； select/poll/epoll核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程 +阻塞IO好，多路复用的模型中，每一个socket，设置为nonblocking，阻塞是被select这个函数block，而不是被socket阻塞的。\n\n1. select机制\n\n   客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)和exceptfds(异常)。select会阻塞住监视3类文件描述符，等有数据、可读、可写、出异常或超时，就会返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后通过进行对应的IO操作。\n\n   缺点：由于是采用轮询方式全盘扫描，会随着文件描述符FD数量增多而性能下降。每次调用select()，需要把fd集合从用户态拷贝到内核态，并进行遍历（消息传递都是从内核到用户空间）默认单个进程打开的FD有限制是1024个，可修改宏定义，但是效率仍然慢。\n\n2. poll机制\n\n   基本原理与select一致，只是没有最大文件描述符限制，因为采用的是链表存储fd。\n\n3. epoll机制\n\n   epoll之所以高性能是得益于它的三个函数\n\n   1. epoll_create()系统启动时，在Linux内核里面申请一个B+树结构文件系统，返回epoll对象，也是一个fd\n   2. epoll_ctl()每新建一个连接，都通过该函数操作epoll对象，在这个对象里面修改、添加、删除对应的链接fd，绑定一个callback函数。\n   3. epoll_wait()轮询所有的callback集合，并完成对应的IO操作。\n\n\n\nepoll是将所有的fd(文件描述符)保存在内核的一块区域内，如果有就绪的fd则会返回完成对应的IO操作。\n\n\n\n### PrintStream、BufferedWriter、PrinterWriter的比较？\n\nPrintStream是打印输出流，继承自OutputStream，它永远不会抛出IOException，提供了自动flush的功能。\n\nPrintStream和PrintWriter的API基本相同，都能输出各种形式的数据，构造方法也几乎相同，PrintWriter多了个接受Writer参数\n\nBufferedWriter：将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过write()方法可以将获取到的字符输出，然后通过newLine()进行换行操作。BufferedWriter中的字符流必须通过调用flush方法才能将其刷出去。并且BufferedWriter只能对字符流进行操作。如果要对字节流操作，则使用BufferedInputStream。\n\n\n\n### 什么是Java序列化？\n\n序列化就是一种用来处理对象流的机制，所谓对象流就是讲对象的内容进行流化。可以对流化后的对象进行读写操作，也可以将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时引发的问题。\n\n\n\n### 如何实现Java序列化？\n\n序列化的实现，将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出路(如File Output Stream)来构造一个Object Output Stream(对象流)对象，接着，使用Object Output Stream对象的write Object(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。\n\n\n\n### Java中有几种类型的流？\n\n1. 按照流的方向：输入流和输出流\n2. 按照实现功能分：节点流（可以从或向一个特定的地方(节点)读写数据。如FileReader)和处理流(是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写,如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数，一个流对象经过其他流的多次包装，称为流的链接)；\n3. 按照处理数据的单位：字节流和字符流。字节流继承于InputStream和OutputStream，字符流继承于InputStreamReader和OutputStreamWriter。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhttps://blog.csdn.net/qq_41112238/article/details/105074636\n\n\n\n\n\n\n\n# 计算机网络\n\n## 计算机网络体系结构\n\n### OSI体系结构\n\n![image-20220202134417880](images/image-20220202134417880.png)\n\n### TCP/IP体系结构\n\n![image-20220202134442868](images/image-20220202134442868.png)\n\n![image-20220202134524830](images/image-20220202134524830.png)\n\n![image-20220202134543881](images/image-20220202134543881.png)\n\n### 原理体系结构\n\n![image-20220202134625726](images/image-20220202134625726.png)\n\n\n\n## TCP连接\n\n### 简述三次握手\n\n第一次握手：客户端将标志为SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端进入syn_sent状态，等待服务端确认。\n\n第二次握手：服务端收到的数据包由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。\n\n第三次握手：客户端收到确认后检查，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了。\n\n### 简述四次挥手\n\n第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait状态。\n\n第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。\n\n第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。\n\n第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。\n\n\n\n\n\n# MySQL\n\n## InnoDB和MyISAM的区别\n\n主要区别是InnoDB支持表锁和行锁，也支持事务。MyISAM只支持表锁，不支持事务。\n\n\n\n## 各种锁\n\nInnoDB的锁：共享锁、排它锁、意向共享锁、意向排它锁\n\n\n\n什么时候使用行级锁？\n\nInnoDB行锁是通过**索引上的索引项**来实现的，这一点MySQL与Oracle不同，后者是通过在数据中对相应数据加锁来实现的。InnoDB这种行锁实现特点意味着：**只有通过索引条件检索数据，InnoDB才会使用行级锁**，否则，InnoDB将使用表锁。\n\n在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立即释放，而是要等到事务结束后才释放，这个就是两阶段锁协议。**\n\n\n\n**间隙锁(Next-key)**：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB（可重复度、串行化级别下才有效）会给符合条件的已有数据的索引项加锁；对于键值再条件范围内但并不存在的记录，就做间隙(GAP)，InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁(Next-key锁)。\n\n\n\n什么时候使用表锁？\n\n对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。\n\n- 第一种情况：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。\n- 第二种情况：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销\n\n\n\n关于死锁？\n\nMyISAM表锁是deadlock free的，这是因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发送死锁是可能的。\n\n1. 主动死锁检测，发生死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。\n2. 直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置(默认50s)。\n\n\n\n对于InnoDB表，主要有以下几点：\n\n1. InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。\n2. InnoDB间隙锁机制，以及InnoDB使用间隙锁的原因。\n3. 在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。\n4. MySQL的恢复和赋值对InnoDB锁机制和一致性读策略也有较大影响。\n5. 锁冲突甚至死锁很难完全避免。\n\n\n\n## 索引\n\n索引是MySQL高效获取数据的数据结构。\n\n主键索引、唯一索引、普通索引、全文索引、组合索引。\n\n\n\nB树和B+树的区别：\n\n- B树：非叶子节点和叶子节点都会存储数据。\n- B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。\n\n\n\n## 如何解决幻读\n\n在PR级别下，快照读是通过MVCC（多版本控制）和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。\n\n\n\n## MySQL体系结构\n\n![image-20220202165937969](images/image-20220202165937969.png)\n\n可以看出MySQL最上层是连接组件，下面服务器是由连接池、管理工具和服务、SQL接口、解析器、优化器、缓存、存储引擎、文件系统组成。\n\n\n\n连接池：由于每次建立连接需要消耗很多时间，连接池的作用就是将这些连接缓存下来，下次可以直接用连接好的连接，提升服务器性能。\n\n管理工具和服务：系统管理和控制工具，例如备份恢复、MySQL复制、集群等。\n\nSQL接口：接受用户的SQL命令，并且返回用户需要查询的结果。比如select from 就是调用SQL Interface。\n\n解析器：SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本，主要功能：\n\n1. 将SQL语句分解成数据结构，并将这个结果传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。\n2. 如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。\n\n优化器：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化，它使用的是“选取-投影-连接”策略进行查询。\n\n缓存器：查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接取查询缓存中取数据。\n\n通过LRU算法将数据的冷端溢出，未来得及时刷新到磁盘的数据页，叫脏页。\n\n这个缓存机制是由一系列小缓存组成的，比如表缓存、记录缓存、key缓存、权限缓存等。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-02-17 14:55:24', '2022-02-17 14:55:24', 0, 15260, 2, 1, 1);
INSERT INTO `blog` VALUES (15, '常用Java类', 'http://up.deskcity.org/pic_360/08/72/70/0872701410f04a527326b0b63fde6254.jpg', '常用Java类', '## 1. Runtime类\n\n- jvm虚拟机注册一个勾子，当虚拟机要关闭时，会执行预先注册的线程任务。\n\n```java\nRuntime.getRuntime().addShutdownHook(new Thread() {\n\n            public void run() {\n                try {\n                    logger.info(\"## stop the canal client\");\n                    clientTest.stop();\n                } catch (Throwable e) {\n                    logger.warn(\"##something goes wrong when stopping canal:\\n{}\", ExceptionUtils.getFullStackTrace(e));\n                } finally {\n                    logger.info(\"## canal client is down.\");\n                }\n            }\n\n        });\n```\n\n[ShutdownHook - java中优雅地停止服务](https://mp.weixin.qq.com/s/z5bfW8OJOYMK-fzSzDOkdg)\n\n- 获取JVM的内存空间信息\n\n## 2. 字符串操作\n\n- StringBuffer 线程安全\n- StringBuilder 非线程安全，适用于单线程，速度快\n\n## 3. 日期操作\n\n- Date\n- Calendar\n- DateFormat\n- SimpleDateFormat\n\n## 4. Math类\n\n## 5. Random类\n\n## 6. DecimalFormat\n\nFormat的一个子类，可以根据用户自定义格式来格式化数字。\n\n```java\nDecimalFormat df=new DecimalFormat(\"###,###.###\");\ndf.format(1234232.1456);\n\n结果\n1,234,232.146\n\n```\n\n## 7. BigInteger类\n\n大整数类。如果在操作时一个整型数据超过了整数的最大长度Long，可以使用此类。\n\n## 8. BigDecimal类\n\nfloat和double无法做到准确的精度计数，如果需要精确的计算结果，可以使用此类。\n\n## 9. Arrays\n\n数组元素的查找、数组内容的填充、排序等。\n\n## 10. Comparable接口\n\n比较器，排序时使用。\n\n```java\npublic interface Comparable<T> {\n   public int compareTo(T o);\n} \n```\n\n与Arrays.sort(Object[] a)方法或者Collections.sort(List list)方法组合使用。\n\n另一种用法：\n\njava.util.Collections.sort(List, Comparator<? super T>)\n\n\n\n\n\n\n\n\n\n', '2022-02-17 14:57:10', '2022-02-17 14:57:10', 0, 1386, 2, 1, 1);
INSERT INTO `blog` VALUES (16, 'Vim分配功能', '', 'vim的分屏功能', '\n\n# 一、vim的分屏功能\n\n### 分屏启动vim\n\n1. 使用小写的o参数来上下分屏（横向分屏）\n\n```\nvim -on file1 file2 ...\n```\n\n2. 使用大写的参数O来左右分屏（纵向分屏）\n\n```\nvim -On file1 file2 ...\n```\n\n**注意：**n是数字，表示分成几个屏\n\n\n\n### 关闭分屏 先同时按住ctrl+w，松开后再按后面的参数\n\n1. 关闭当前窗口\n\n```\nCtrl+W c\n```\n\n2. 关闭当前窗口，如果只剩最后一个了，则退出vim\n\n```\nCtrl+W q\n```\n\n3. 把光标移到下一个屏中\n\n```\nCtrl+W w\n```\n\n\n\n### 分屏\n\n1. 上下分割当前打开的文件\n\n```\nCtrl+W s\n```\n\n2. 左右分割当前打开的文件\n\n```\nCtrl+W v\n```\n\n3. 上下分割，并打开一个新的文件\n\n```\n:sp filename\n```\n\n4. 左右分割，并打开一个新的文件\n\n```\n:vsp filename\n```\n\n\n\n### 移动光标\n\nVI中的光标键是h,j,k,l,要在各个屏间切换，只需要先按一下Ctrl+W\n\n1. 把光标移动到右边的屏\n\n```\nCtrl+W l\n```\n\n2. 把光标移到左边的屏\n\n```\nCtrl+W h\n```\n\n3. 把光标移到下边的屏\n\n```\nCtrl+w j\n```\n\n4. 把光标移到上边的屏\n\n```\nCtrl+w k\n```\n\n5. 把光标移到下一个屏中\n\n```\nCtrl+W w\n```\n\n\n\n### 移动分屏\n\n1. 向右移动\n\n```\nCtrl+W L\n```\n\n2. 向左移动\n\n```\nCtrl+w H\n```\n\n3. 向上移动\n\n```\nCtrl+w K\n```\n\n4. 向下移动\n\n```\nCtrl+w J\n```\n\n\n\n### 屏幕尺寸\n\n对于宽度可以使用Ctrl+W < 或 >, 但这可能需要最新的版本才能支持。\n\n1. 让所有的屏都有一样的高度\n\n```\nCtrl+W =\n```\n\n2. 增加高度\n\n```\nCtrl+W +\n```\n\n3. 减少高度\n\n```\nCtrl+W -\n```\n\n\n# vim打开多个文件、同时显示多个文件、在文件之间切换\n\n## 打开多个文件\n\n1. vim还没有启动的时候\n\n```\nvim file1 file2 ... filen \n```\n\n2. vim已经启动\n\n```\nopen file\n```\n\n可以再打开一个文件，并且此时vim中会显示出file文件的内容\n\n```\n:e ../myFile\n```\n\n此方式可以再编辑一个文档的同时打开另一个文档\n\n## 同时显示多个文件\n\n```\n:split   简写 :sp\n:vsplit  简写 :vsp\n:ls     # 显示缓存\n```\n\n## 在文件之间切换\n\n1. 文件间切换\n\nCtrl + 6  -- 下一个文件\n\n```\n:bn -- 下一个文件\n:bp -- 上一个文件\n```\n\n3. 多文档编辑的命令如下\n\n```\n:n   编辑下一个文档\n:2n  编辑下两个文档\n:N  编辑上一个文档\n:e 文档名   这是进入vim后，不离开vim的情形下打开其他文档\n:e#  或 Ctrl+^  编辑上一个文档，用于两个文档相互交换编辑时使用，?#代表的是编辑前一次编辑的文档\n:files 或 :buffer 或 :ls  可以列出目前缓冲区中的所有文档。加号+表示缓冲区已经被修改过了。 #代表上一次编辑的文档， %是目前正在编辑中的文档。\n:b 文档名或编号  \n:f 或 Ctrl+g  显示当前正在编辑的文档名称\n```\n\n\n\n\n\n### 分屏切换\n\n- `Ctrl-W L`:切换到右边窗\n- `Ctrl-W H`:切换到左边窗\n- `Ctrl-W J`:切换到上边窗\n- `Ctrl-W K`:切换到下边窗\n- gt 下一个标签页\n- gT 上一个标签页\n\n\n\n\n\n#### 分屏启动Vim\n\n1. 使用大写的O参数来垂直分屏。\n\n   ```\n   vim -On file1 file2 ...\n   ```\n\n2. 使用小写的o参数来水平分屏。\n\n   ```\n   vim -on file1 file2 ...\n   ```\n\n**注释:** n是数字，表示分成几个屏。\n\n#### 关闭分屏\n\n1. 关闭当前窗口。\n\n   ```\n   Ctrl+W c\n   ```\n\n2. 关闭当前窗口，如果只剩最后一个了，则退出Vim。\n\n   ```\n   Ctrl+W q\n   ```\n\n#### 分屏\n\n1. 上下分割当前打开的文件。\n\n   ```\n   Ctrl+W s\n   ```\n\n2. 上下分割，并打开一个新的文件。\n\n   ```\n   :sp filename\n   ```\n\n3. 左右分割当前打开的文件。\n\n   ```\n   Ctrl+W v\n   ```\n\n4. 左右分割，并打开一个新的文件。\n\n   ```\n   :vsp filename\n   ```\n\n#### 移动光标\n\nVi中的光标键是h, j, k, l，要在各个屏间切换，只需要先按一下Ctrl+W\n\n1. 把光标移到右边的屏。\n\n   ```\n   Ctrl+W l\n   ```\n\n2. 把光标移到左边的屏中。\n\n   ```\n   Ctrl+W h\n   ```\n\n3. 把光标移到上边的屏中。\n\n   ```\n   Ctrl+W k\n   ```\n\n4. 把光标移到下边的屏中。\n\n   ```\n   Ctrl+W j\n   ```\n\n5. 把光标移到下一个的屏中。.\n\n   ```\n   Ctrl+W w\n   ```\n\n#### 移动分屏\n\n这个功能还是使用了Vim的光标键，只不过都是大写。当然了，如果你的分屏很乱很复杂的话，这个功能可能会出现一些非常奇怪的症状。\n\n1. 向右移动。\n\n   ```\n   Ctrl+W L\n   ```\n\n2. 向左移动\n\n   ```\n   Ctrl+W H\n   ```\n\n3. 向上移动\n\n   ```\n   Ctrl+W K\n   ```\n\n4. 向下移动\n\n   ```\n   Ctrl+W J\n   ```\n\n#### 屏幕尺寸\n\n下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用[Ctrl+W <]或是[Ctrl+W >]，但这可能需要最新的版本才支持。\n\n1. 让所有的屏都有一样的高度。\n\n   ```\n   Ctrl+W =\n   ```\n\n2. 增加高度。\n\n   ```\n   Ctrl+W +\n   ```\n\n3. 减少高度。\n\n   ```\n   Ctrl+W -\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2022-02-17 14:59:03', '2022-02-17 14:59:03', 0, 2842, 4, 1, 1);
INSERT INTO `blog` VALUES (17, 'snap安装卸载软件常用命令', '', 'ubuntu软件安装', 'snap安装包是Cononical公司发布的全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。所以使用snap包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。\n\nsnap应用可以安装同一个软件的不同版本。snap的安装包的扩展名为.snap，类似于一个容器，它包含一个应用程序需要用到的所有文件和库。\n\nsnap软件包一般安装在/snap目录下。\n\n## 一些常用的命令\n\n#### 列出已经安装的snap包\n\n```sh\nsudo snap list\n```\n\n#### 搜索要安装的snap包\n\n```sh\nsudo snap find <text to search>\n```\n\n#### 安装一个snap包\n\n```sh\nsudo snap install <snap name>\n```\n\n#### 更新一个snap包\n\n```sh\nsudo snap refresh <snap name>\n```\n\n#### 把一个包还原到以前安装的版本\n\n```sh\nsudo snap revert <snap name>\n```\n\n#### 删除一个snap包\n\n```sh\nsudo snap remove <snap name>\n```\n\n\n\n', '2022-02-17 15:01:11', '2022-02-17 15:01:11', 0, 555, 4, 1, 1);
INSERT INTO `blog` VALUES (18, 'Maven教程之pom', 'http://up.deskcity.org/pic_360/202010/sl/cz0rijxghou5517.jpg', 'maven', '> 作者：dunwu\n> [https://github.com/dunwu/blog](https://link.zhihu.com/?target=https%3A//github.com/dunwu/blog)\n\n## 简介\n\n### 什么是 pom？\n\n**POM 是 Project Object Model 的缩写，即项目对象模型。**\n\n[pom.xml](https://www.zhihu.com/search?q=pom.xml&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769}) 就是 maven 的配置文件，用以描述项目的各种信息。\n\n### pom 配置一览\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <!-- The Basics -->\n  <groupId>...</groupId>\n  <artifactId>...</artifactId>\n  <version>...</version>\n  <packaging>...</packaging>\n  <dependencies>...</dependencies>\n  <parent>...</parent>\n  <dependencyManagement>...</dependencyManagement>\n  <modules>...</modules>\n  <properties>...</properties>\n\n  <!-- Build Settings -->\n  <build>...</build>\n  <reporting>...</reporting>\n\n  <!-- More Project Information -->\n  <name>...</name>\n  <description>...</description>\n  <url>...</url>\n  <inceptionYear>...</inceptionYear>\n  <licenses>...</licenses>\n  <organization>...</organization>\n  <developers>...</developers>\n  <contributors>...</contributors>\n\n  <!-- Environment Settings -->\n  <issueManagement>...</issueManagement>\n  <ciManagement>...</ciManagement>\n  <mailingLists>...</mailingLists>\n  <scm>...</scm>\n  <prerequisites>...</prerequisites>\n  <repositories>...</repositories>\n  <pluginRepositories>...</pluginRepositories>\n  <distributionManagement>...</distributionManagement>\n  <profiles>...</profiles>\n</project>\n```\n\n## 基本配置\n\n- **project** - `project` 是 pom.xml 中描述符的根。\n- **modelVersion** - `modelVersion` 指定 pom.xml 符合哪个版本的描述符。maven 2 和 3 只能为 4.0.0。\n\n一般 jar 包被识别为： `groupId:artifactId:version` 的形式。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>org.codehaus.mojo</groupId>\n  <artifactId>my-project</artifactId>\n  <version>1.0</version>\n  <packaging>war</packaging>\n</project>\n```\n\n### maven 坐标\n\n**在 maven 中，根据 `groupId`、`artifactId`、`version` 组合成 `groupId:artifactId:version` 来唯一识别一个 jar 包。**\n\n- **groupId** - 团体、组织的标识符。团体标识的约定是，它以创建这个项目的组织名称的逆向域名(reverse domain name)开头。一般对应着 java 的包结构。\n\n- **artifactId** - 单独项目的唯一标识符。比如我们的 tomcat、commons 等。不要在 artifactId 中包含点号(.)。\n\n- **version** - 一个项目的特定版本。\n\n- maven 有自己的版本规范，一般是如下定义 [major version](https://www.zhihu.com/search?q=major+version&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769})、minor version、incremental version-qualifier ，比如 1.2.3-beta-01。要说明的是，maven 自己判断版本的算法是 major、minor、incremental 部分用数字比较，qualifier 部分用字符串比较，所以要小心 alpha-2 和 alpha-15 的比较关系，最好用 alpha-02 的格式。\n\n- maven 在版本管理时候可以使用几个特殊的字符串 SNAPSHOT、LATEST、RELEASE。比如 `1.0-SNAPSHOT`。各个部分的含义和处理逻辑如下说明：\n\n- - **SNAPSHOT** - 这个版本一般用于开发过程中，表示不稳定的版本。\n    - **LATEST** - 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个 snapshot 版，具体看哪个时间最后。\n    - **RELEASE** ：指最后一个发布版。\n\n- **packaging** - 项目的类型，描述了项目打包后的输出，默认是 jar。常见的输出类型为：pom, jar, [maven-plugin](https://www.zhihu.com/search?q=maven-plugin&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769}), ejb, war, ear, rar, par。\n\n## 依赖配置\n\n### dependencies\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <dependencies>\n    <dependency>\n     <groupId>org.apache.maven</groupId>\n      <artifactId>maven-embedder</artifactId>\n      <version>2.0</version>\n      <type>jar</type>\n      <scope>test</scope>\n      <optional>true</optional>\n      <exclusions>\n        <exclusion>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-core</artifactId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    ...\n  </dependencies>\n  ...\n</project>\n```\n\n\n\n- **groupId**, **artifactId**, **version** - 和基本配置中的 `groupId`、`artifactId`、`version` 意义相同。\n- **type** - 对应 `packaging` 的类型，如果不使用 `type` 标签，maven 默认为 jar。\n- **scope** - 此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：\n- **compile** - 如果没有指定 `scope` 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。\n- **provided** - 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。\n- **runtime** - 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。\n- **test** - 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。\n- **system** - 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。\n- **systemPath** - 仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 `propertie` 来指定特定的路径，如`\\$ {java.home} / lib`。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。\n- **optional** - `optional` 让其他项目知道，当您使用此项目时，您不需要这种依赖性才能正常工作。\n- **exclusions** - 包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 `groupId` 和 `artifactId`。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。\n\n### parent\n\nmaven 支持继承功能。子 POM 可以使用 `parent` 指定父 POM ，然后继承其配置。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <parent>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>my-parent</artifactId>\n    <version>2.0</version>\n    <relativePath>../my-parent</relativePath>\n  </parent>\n\n  <artifactId>my-project</artifactId>\n</project>\n```\n\n\n\n- **relativePath** - 注意 `relativePath` 元素。在搜索本地和远程存储库之前，它不是必需的，但可以用作 maven 的指示符，以首先搜索给定该项目父级的路径。\n\n### dependencyManagement\n\n`dependencyManagement` 是表示依赖 jar 包的声明。即你在项目中的 `dependencyManagement` 下声明了依赖，maven 不会加载该依赖，`dependencyManagement` 声明可以被子 POM 继承。\n\n`dependencyManagement` 的一个使用案例是当有父子项目的时候，父项目中可以利用 `dependencyManagement` 声明子项目中需要用到的依赖 jar 包，之后，当某个或者某几个子项目需要加载该依赖的时候，就可以在子项目中 `dependencies` 节点只配置 `groupId` 和 `artifactId` 就可以完成依赖的引用。\n\n`dependencyManagement` 主要是为了统一管理依赖包的版本，确保所有子项目使用的版本一致，类似的还有`plugins`和`pluginManagement`。\n\n### modules\n\n子模块列表。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>org.codehaus.mojo</groupId>\n  <artifactId>my-parent</artifactId>\n  <version>2.0</version>\n  <packaging>pom</packaging>\n\n  <modules>\n    <module>my-project</module>\n    <module>another-project</module>\n    <module>third-project/pom-example.xml</module>\n  </modules>\n</project>\n```\n\n### properties\n\n属性列表。定义的属性可以在 pom.xml 文件中任意处使用。使用方式为 `${propertie}` 。\n\n```text\n<project>\n  ...\n  <properties>\n    <maven.compiler.source>1.7<maven.compiler.source>\n    <maven.compiler.target>1.7<maven.compiler.target>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n  </properties>\n  ...\n</project>\n```\n\n## 构建配置\n\n### build\n\nbuild 可以分为 \"project build\" 和 \"profile build\"。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <!-- \"Project Build\" contains more elements than just the BaseBuild set -->\n  <build>...</build>\n\n  <profiles>\n    <profile>\n      <!-- \"Profile Build\" contains a subset of \"Project Build\"s elements -->\n      <build>...</build>\n    </profile>\n  </profiles>\n</project>\n```\n\n基本构建配置：\n\n```text\n<build>\n  <defaultGoal>install</defaultGoal>\n  <directory>${basedir}/target</directory>\n  <finalName>${artifactId}-${version}</finalName>\n  <filters>\n    <filter>filters/filter1.properties</filter>\n  </filters>\n  ...\n</build>\n```\n\n**defaultGoal** : 默认执行目标或阶段。如果给出了一个目标，它应该被定义为它在命令行中（如 jar：jar）。如果定义了一个阶段（如安装），也是如此。\n\n**directory** ：构建时的输出路径。默认为：`${basedir}/target` 。\n\n**finalName** ：这是项目的最终构建名称（不包括文件扩展名，例如：my-project-1.0.jar）\n\n**filter** ：定义 `* .properties` 文件，其中包含适用于接受其设置的资源的属性列表（如下所述）。换句话说，过滤器文件中定义的“name = value”对在代码中替换`\\$ {name}`字符串。\n\n### resources\n\n资源的配置。[资源文件](https://www.zhihu.com/search?q=资源文件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769})通常不是代码，不需要编译，而是在项目需要捆绑使用的内容。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <build>\n    ...\n    <resources>\n      <resource>\n        <targetPath>META-INF/plexus</targetPath>\n        <filtering>false</filtering>\n        <directory>${basedir}/src/main/plexus</directory>\n        <includes>\n          <include>configuration.xml</include>\n        </includes>\n        <excludes>\n          <exclude>**/*.properties</exclude>\n        </excludes>\n      </resource>\n    </resources>\n    <testResources>\n      ...\n    </testResources>\n    ...\n  </build>\n</project>\n```\n\n\n\n- **resources**: 资源元素的列表，每个资源元素描述与此项目关联的文件和何处包含文件。\n- **targetPath**: 指定从构建中放置资源集的目录结构。[目标路径](https://www.zhihu.com/search?q=目标路径&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769})默认为基本目录。将要包装在 jar 中的资源的通常指定的目标路径是 META-INF。\n- **filtering**: 值为 true 或 false。表示是否要为此资源启用过滤。请注意，该过滤器 `* .properties` 文件不必定义为进行过滤 - 资源还可以使用默认情况下在 POM 中定义的属性（例如\\$ {project.version}），并将其传递到命令行中“-D”标志（例如，“-Dname = value”）或由 properties 元素显式定义。过滤文件覆盖上面。\n- **directory**: 值定义了资源的路径。构建的默认目录是`${basedir}/src/main/resources`。\n- **includes**: 一组文件匹配模式，指定目录中要包括的文件，使用*作为[通配符](https://www.zhihu.com/search?q=通配符&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769})。\n- **excludes**: 与 `includes` 类似，指定目录中要排除的文件，使用*作为通配符。注意：如果 `include` 和 `exclude` 发生冲突，maven 会以 `exclude` 作为有效项。\n- **testResources**: `testResources` 与 `resources` 功能类似，区别仅在于：`testResources` 指定的资源仅用于 test 阶段，并且其默认资源目录为：`${basedir}/src/test/resources` 。\n\n### plugins\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <build>\n    ...\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <version>2.6</version>\n        <extensions>false</extensions>\n        <inherited>true</inherited>\n        <configuration>\n          <classifier>test</classifier>\n        </configuration>\n        <dependencies>...</dependencies>\n        <executions>...</executions>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n```\n\n- **groupId**, **artifactId**, **version** ：和基本配置中的 `groupId`、`artifactId`、`version` 意义相同。\n- **extensions** ：值为 true 或 false。是否加载此插件的扩展名。默认为 false。\n- **inherited** ：值为 true 或 false。这个插件配置是否应该适用于继承自这个插件的 POM。默认值为 true。\n- **configuration** - 这是针对个人插件的配置，这里不扩散讲解。\n- **dependencies** ：这里的 `dependencies` 是插件本身所需要的依赖。\n- **executions** ：需要记住的是，插件可能有多个目标。每个目标可能有一个单独的配置，甚至可能将插件的目标完全绑定到不同的阶段。执行配置插件的目标的执行。\n- **id**: 执行目标的标识。\n- **goals**: 像所有多元化的 POM 元素一样，它包含单个元素的列表。在这种情况下，这个执行块指定的插件目标列表。\n- **phase**: 这是执行目标列表的阶段。这是一个非常强大的选项，允许将任何目标绑定到构建生命周期中的任何阶段，从而改变 maven 的默认行为。\n- **inherited**: 像上面的继承元素一样，设置这个 false 会阻止 maven 将这个执行传递给它的子代。此元素仅对父 POM 有意义。\n- **configuration**: 与上述相同，但将配置限制在此特定目标列表中，而不是插件下的所有目标。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <build>\n    <plugins>\n      <plugin>\n        <artifactId>maven-antrun-plugin</artifactId>\n        <version>1.1</version>\n        <executions>\n          <execution>\n            <id>echodir</id>\n            <goals>\n              <goal>run</goal>\n            </goals>\n            <phase>verify</phase>\n            <inherited>false</inherited>\n            <configuration>\n              <tasks>\n                <echo>Build Dir: ${project.build.directory}</echo>\n              </tasks>\n            </configuration>\n          </execution>\n        </executions>\n\n      </plugin>\n    </plugins>\n  </build>\n</project>\n```\n\n### pluginManagement\n\n与 `dependencyManagement` 很相似，在当前 POM 中仅声明插件，而不是实际引入插件。子 POM 中只配置 `groupId` 和 `artifactId` 就可以完成插件的引用，且子 POM 有权重写 pluginManagement 定义。\n\n它的目的在于统一所有子 POM 的插件版本。\n\n### directories\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <build>\n    <sourceDirectory>${basedir}/src/main/java</sourceDirectory>\n    <scriptSourceDirectory>${basedir}/src/main/scripts</scriptSourceDirectory>\n    <testSourceDirectory>${basedir}/src/test/java</testSourceDirectory>\n    <outputDirectory>${basedir}/target/classes</outputDirectory>\n    <testOutputDirectory>${basedir}/target/test-classes</testOutputDirectory>\n    ...\n  </build>\n</project>\n```\n\n目录元素集合存在于 `build` 元素中，它为整个 POM 设置了各种目录结构。由于它们在配置文件构建中不存在，所以这些不能由配置文件更改。\n\n如果上述目录元素的值设置为绝对路径（扩展属性时），则使用该目录。否则，它是相对于基础构建目录：`${basedir}`。\n\n### extensions\n\n扩展是在此构建中使用的 artifacts 的列表。它们将被包含在运行构建的 classpath 中。它们可以启用对构建过程的扩展（例如为 Wagon 传输机制添加一个 ftp 提供程序），并使活动的插件能够对构建生命周期进行更改。简而言之，扩展是在构建期间激活的 artifacts。扩展不需要实际执行任何操作，也不包含 Mojo。因此，扩展对于指定普通插件接口的多个实现中的一个是非常好的。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <build>\n    ...\n    <extensions>\n      <extension>\n        <groupId>org.apache.maven.wagon</groupId>\n        <artifactId>wagon-ftp</artifactId>\n        <version>1.0-alpha-3</version>\n      </extension>\n    </extensions>\n    ...\n  </build>\n</project>\n```\n\n### reporting\n\n报告包含特定针对 `site` 生成阶段的元素。某些 maven 插件可以生成 `reporting` 元素下配置的报告，例如：生成 javadoc 报告。`reporting` 与 `build` 元素配置插件的能力相似。明显的区别在于：在执行块中插件目标的控制不是细粒度的，报表通过配置 `reportSet` 元素来精细控制。\n\n而微妙的区别在于 `reporting` 元素下的 `configuration` 元素可以用作 `build` 下的 `configuration` ，尽管相反的情况并非如此（ `build` 下的 `configuration` 不影响 `reporting` 元素下的 `configuration` ）。\n\n另一个区别就是 `plugin` 下的 `outputDirectory` 元素。在报告的情况下，默认输出目录为 `${basedir}/target/site`。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <reporting>\n    <plugins>\n      <plugin>\n        ...\n        <reportSets>\n          <reportSet>\n            <id>sunlink</id>\n            <reports>\n              <report>javadoc</report>\n            </reports>\n            <inherited>true</inherited>\n            <configuration>\n              <links>\n                <link>http://java.sun.com/j2se/1.5.0/docs/api/</link>\n              </links>\n            </configuration>\n          </reportSet>\n        </reportSets>\n      </plugin>\n    </plugins>\n  </reporting>\n  ...\n</project>\n```\n\n## [项目信息](https://www.zhihu.com/search?q=项目信息&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A76874769})\n\n项目信息相关的这部分标签**都不是必要的**，也就是说完全可以不填写。\n\n它的作用仅限于描述项目的详细信息。\n\n下面的示例是项目信息相关标签的清单：\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n\n  <!-- 项目信息 begin -->\n\n  <!--项目名-->\n  <name>maven-notes</name>\n\n  <!--项目描述-->\n  <description>maven 学习笔记</description>\n\n  <!--项目url-->\n  <url>https://github.com/dunwu/maven-notes</url>\n\n  <!--项目开发年份-->\n  <inceptionYear>2017</inceptionYear>\n\n  <!--开源协议-->\n  <licenses>\n    <license>\n      <name>Apache License, Version 2.0</name>\n      <url>https://www.apache.org/licenses/LICENSE-2.0.txt</url>\n      <distribution>repo</distribution>\n      <comments>A business-friendly OSS license</comments>\n    </license>\n  </licenses>\n\n  <!--组织信息(如公司、开源组织等)-->\n  <organization>\n    <name>...</name>\n    <url>...</url>\n  </organization>\n\n  <!--开发者列表-->\n  <developers>\n    <developer>\n      <id>victor</id>\n      <name>Zhang Peng</name>\n      <email>forbreak at 163.com</email>\n      <url>https://github.com/dunwu</url>\n      <organization>...</organization>\n      <organizationUrl>...</organizationUrl>\n      <roles>\n        <role>architect</role>\n        <role>developer</role>\n      </roles>\n      <timezone>+8</timezone>\n      <properties>...</properties>\n    </developer>\n  </developers>\n\n  <!--代码贡献者列表-->\n   <contributors>\n    <contributor>\n      <!--标签内容和<developer>相同-->\n    </contributor>\n  </contributors>\n\n  <!-- 项目信息 end -->\n\n  ...\n</project>\n```\n\n这部分标签都非常简单，基本都能做到顾名思义，且都属于可有可无的标签，所以这里仅简单介绍一下：\n\n- **name** - 项目完整名称\n- **description** - 项目描述\n- **url** - 一般为项目仓库的 host\n- **inceptionYear** - 开发年份\n- **licenses** - 开源协议\n- **organization** - 项目所属组织信息\n- **developers** - 项目开发者列表\n- **contributors** - 项目贡献者列表， 的子标签和 的完全相同。\n\n## 环境配置\n\n### issueManagement\n\n这定义了所使用的缺陷跟踪系统（Bugzilla，TestTrack，ClearQuest 等）。虽然没有什么可以阻止插件使用这些信息的东西，但它主要用于生成项目文档。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <issueManagement>\n    <system>Bugzilla</system>\n    <url>http://127.0.0.1/bugzilla/</url>\n  </issueManagement>\n  ...\n</project>\n```\n\n### ciManagement\n\nCI 构建系统配置，主要是指定通知机制以及被通知的邮箱。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <ciManagement>\n    <system>continuum</system>\n    <url>http://127.0.0.1:8080/continuum</url>\n    <notifiers>\n      <notifier>\n        <type>mail</type>\n        <sendOnError>true</sendOnError>\n        <sendOnFailure>true</sendOnFailure>\n        <sendOnSuccess>false</sendOnSuccess>\n        <sendOnWarning>false</sendOnWarning>\n        <configuration><address>continuum@127.0.0.1</address></configuration>\n      </notifier>\n    </notifiers>\n  </ciManagement>\n  ...\n</project>\n```\n\n### mailingLists\n\n邮件列表\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <mailingLists>\n    <mailingList>\n      <name>User List</name>\n      <subscribe>user-subscribe@127.0.0.1</subscribe>\n      <unsubscribe>user-unsubscribe@127.0.0.1</unsubscribe>\n      <post>user@127.0.0.1</post>\n      <archive>http://127.0.0.1/user/</archive>\n      <otherArchives>\n        <otherArchive>http://base.google.com/base/1/127.0.0.1</otherArchive>\n      </otherArchives>\n    </mailingList>\n  </mailingLists>\n  ...\n</project>\n```\n\n### scm\n\nSCM（软件配置管理，也称为源代码/控制管理或简洁的版本控制）。常见的 scm 有 svn 和 git 。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <scm>\n    <connection>scm:svn:http://127.0.0.1/svn/my-project</connection>\n    <developerConnection>scm:svn:https://127.0.0.1/svn/my-project</developerConnection>\n    <tag>HEAD</tag>\n    <url>http://127.0.0.1/websvn/my-project</url>\n  </scm>\n  ...\n</project>\n```\n\n### prerequisites\n\nPOM 执行的预设条件。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <prerequisites>\n    <maven>2.0.6</maven>\n  </prerequisites>\n  ...\n</project>\n```\n\n### repositories\n\n`repositories` 是遵循 Maven 存储库目录布局的 artifacts 集合。默认的 Maven 中央存储库位于[https://repo.maven.apache.org/maven2/](https://link.zhihu.com/?target=https%3A//repo.maven.apache.org/maven2/)上。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <repositories>\n    <repository>\n      <releases>\n        <enabled>false</enabled>\n        <updatePolicy>always</updatePolicy>\n        <checksumPolicy>warn</checksumPolicy>\n      </releases>\n      <snapshots>\n        <enabled>true</enabled>\n        <updatePolicy>never</updatePolicy>\n        <checksumPolicy>fail</checksumPolicy>\n      </snapshots>\n      <id>codehausSnapshots</id>\n      <name>Codehaus Snapshots</name>\n      <url>http://snapshots.maven.codehaus.org/maven2</url>\n      <layout>default</layout>\n    </repository>\n  </repositories>\n  <pluginRepositories>\n    ...\n  </pluginRepositories>\n  ...\n</project>\n```\n\n### pluginRepositories\n\n与 `repositories` 差不多。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <distributionManagement>\n    ...\n    <downloadUrl>http://mojo.codehaus.org/my-project</downloadUrl>\n    <status>deployed</status>\n  </distributionManagement>\n  ...\n</project>\n```\n\n### distributionManagement\n\n它管理在整个构建过程中生成的 artifact 和支持文件的分布。从最后的元素开始：\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <distributionManagement>\n    ...\n    <downloadUrl>http://mojo.codehaus.org/my-project</downloadUrl>\n    <status>deployed</status>\n  </distributionManagement>\n  ...\n</project>\n```\n\n- **repository** - 与 `repositories` 相似\n- **site** - 站点信息\n- **relocation** - 项目迁移位置\n\n### profiles\n\n`activation` 是一个 `profile` 的关键。配置文件的功能来自于在某些情况下仅修改基本 POM 的功能。这些情况通过 `activation` 元素指定。\n\n```text\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n                      https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  ...\n  <profiles>\n    <profile>\n      <id>test</id>\n      <activation>\n        <activeByDefault>false</activeByDefault>\n        <jdk>1.5</jdk>\n        <os>\n          <name>Windows XP</name>\n          <family>Windows</family>\n          <arch>x86</arch>\n          <version>5.1.2600</version>\n        </os>\n        <property>\n          <name>sparrow-type</name>\n          <value>African</value>\n        </property>\n        <file>\n          <exists>${basedir}/file2.properties</exists>\n          <missing>${basedir}/file1.properties</missing>\n        </file>\n      </activation>\n      ...\n    </profile>\n  </profiles>\n</project>\n```\n\n## 参考资料\n\n[Maven - POM Referencemaven.apache.org/pom.html](https://link.zhihu.com/?target=https%3A//maven.apache.org/pom.html)\n\n\n\n**推荐阅读(点击即可跳转阅读)**\n\n**1.** [SpringBoot内容聚合](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247488811%26idx%3D2%26sn%3D0d054027651bef114ae6bec5a8f62359%26chksm%3Debd62a07dca1a3111269692dd9b0a5ab8af7d2038b8ec6600a057573364e76db1332adc5fd46%26scene%3D21%23wechat_redirect)\n\n**2.** [面试题内容聚合](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247488811%26idx%3D3%26sn%3Db04d8fdacf575c7ec959de4107f31091%26chksm%3Debd62a07dca1a31186f7f62de60ba7c7a88db26233562ed7183c6f609c5e7f4ffb448f30375f%26scene%3D21%23wechat_redirect)\n\n**3.** [设计模式内容聚合](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247488811%26idx%3D4%26sn%3Dec20f59a5b67a59d98d221bd20d78448%26chksm%3Debd62a07dca1a31188dafea0e6984b4883fa972a32ff31da2df6f52fcc73b56c6c9454751d73%26scene%3D21%23wechat_redirect)\n\n**4.** [Mybatis内容聚合](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI4Njc5NjM1NQ%3D%3D%26mid%3D2247488945%26idx%3D2%26sn%3D2c0326af621ac51f33720e2608121cef%26chksm%3Debd62a9ddca1a38b8e284b413a8eea08aa452fdeda3c4740325803514d30029a2ab4af5bdfed%26scene%3D21%23wechat_redirect)\n\n**5.** [多线程内容聚合](', '2022-02-17 15:11:22', '2022-02-17 15:11:22', 0, 25015, 4, 1, 1);
COMMIT;

-- ----------------------------
-- Table structure for blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `blog_tag`;
CREATE TABLE `blog_tag` (
  `blog_id` bigint NOT NULL,
  `tag_id` bigint NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of blog_tag
-- ----------------------------
BEGIN;
INSERT INTO `blog_tag` VALUES (1, 2);
INSERT INTO `blog_tag` VALUES (1, 3);
INSERT INTO `blog_tag` VALUES (2, 3);
INSERT INTO `blog_tag` VALUES (3, 3);
INSERT INTO `blog_tag` VALUES (7, 3);
INSERT INTO `blog_tag` VALUES (9, 3);
INSERT INTO `blog_tag` VALUES (10, 3);
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '邮箱',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像(图片路径)',
  `create_time` datetime DEFAULT NULL COMMENT '评论时间',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '评论者ip地址',
  `is_admin_comment` int NOT NULL COMMENT '博主回复',
  `is_published` bit(1) NOT NULL DEFAULT b'1' COMMENT '公开或非公开',
  `blog_id` bigint DEFAULT NULL COMMENT '所属的文章',
  `parent_comment_id` bigint DEFAULT NULL COMMENT '父评论id，-1为根评论',
  `website` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '个人网站',
  `parent_comment_nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '被回复昵称',
  `qq` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '如果评论昵称为QQ号，则将昵称和头像置为QQ昵称和QQ头像，并将此字段置为QQ号备份',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
INSERT INTO `comment` VALUES (7, '2633622312', '2633622312@qq.com', 'test', 'https://cdn.jsdelivr.net/gh/yubifeng/blog-resource/bloghosting/2021/avatar/avatar1.webp', '2022-02-16 18:35:38', NULL, -1, b'1', 10, -1, '', '', '');
INSERT INTO `comment` VALUES (8, 'Giaming', '2633622312@qq.com', 'test', 'http://r7eb8ajdr.hd-bkt.clouddn.com/avatar/avatar9.webp', '2022-02-17 14:41:35', NULL, -1, b'1', 11, -1, '', '', '');
INSERT INTO `comment` VALUES (9, '1111', '111@qq.com', 'test', 'http://r7eb8ajdr.hd-bkt.clouddn.com/avatar/avatar1.webp', '2022-02-17 14:59:36', NULL, -1, b'1', 16, -1, '', '', '');
COMMIT;

-- ----------------------------
-- Table structure for friend
-- ----------------------------
DROP TABLE IF EXISTS `friend`;
CREATE TABLE `friend` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '描述',
  `website` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '站点',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像',
  `is_published` bit(1) NOT NULL DEFAULT b'1' COMMENT '公开或隐藏',
  `views` int NOT NULL DEFAULT '0' COMMENT '点击次数',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of friend
-- ----------------------------
BEGIN;
INSERT INTO `friend` VALUES (1, 'SuiNian\'s Blog', '你歪头眯眼一笑 我便沉溺无法逃离', 'https://blog.nianbroken.top', 'https://blog.nianbroken.top/favicon.png', b'1', 1, '2021-12-05 08:05:49');
INSERT INTO `friend` VALUES (2, '听得入迷空间', '记录，感受，表达', 'https://blog.tdrme.cn', 'https://cdn.jsdelivr.net/gh/tdrme/tdrme.github.io@master/20210504090204404.png', b'1', 0, '2022-01-05 08:05:49');
INSERT INTO `friend` VALUES (3, '夕阳皎月的个人博客', 'When KobeBryant died,a piece of me died.', 'http://www.twilightjy.com/', 'https://cdn.jsdelivr.net/gh/yubifeng/blog-resource/bloghosting/website/friend/myavatar.jpg', b'1', 0, '2022-02-05 08:05:49');
INSERT INTO `friend` VALUES (4, '空山柠语', '歲時艱，行路難。形將破，意且存，勿忘我', 'http://www.lemjuice.cn/', 'http://www.lemjuice.cn/00000147.png', b'1', 0, '2022-02-05 08:05:49');
INSERT INTO `friend` VALUES (5, 'ZhaoQuinn\'s Blog', '热爱科技，热爱生活.', 'https://zhaoq.me', 'https://zhaoq.me/usr/uploads/2020/03/2395074381.jpg', b'1', 0, '2022-02-05 08:05:49');
COMMIT;

-- ----------------------------
-- Table structure for site_setting
-- ----------------------------
DROP TABLE IF EXISTS `site_setting`;
CREATE TABLE `site_setting` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name_en` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `name_zh` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `value` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci,
  `type` int DEFAULT NULL COMMENT '1基础设置，2页脚徽标，3资料卡，4友链信息',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of site_setting
-- ----------------------------
BEGIN;
INSERT INTO `site_setting` VALUES (1, 'webTitleSuffix', '网页标题后缀', ' - Naccl\'s Blog', 1);
INSERT INTO `site_setting` VALUES (2, 'blogName', '博客名称', 'Naccl\'s Blog', 1);
INSERT INTO `site_setting` VALUES (3, 'footerImgTitle', '页脚图片标题', '手机看本站', 1);
INSERT INTO `site_setting` VALUES (4, 'footerImgUrl', '页脚图片路径', '/img/qr.png', 1);
INSERT INTO `site_setting` VALUES (5, 'copyright', 'Copyright', '{\"title\":\"Copyright © 2019 - 2020\",\"siteName\":\"NACCL\'S BLOG\"}', 1);
INSERT INTO `site_setting` VALUES (6, 'beian', 'ICP备案号', '', 1);
INSERT INTO `site_setting` VALUES (7, 'badge', '徽标', '{\"title\":\"由 Spring Boot 强力驱动\",\"url\":\"https://spring.io/projects/spring-boot/\",\"subject\":\"Powered\",\"value\":\"Spring Boot\",\"color\":\"blue\"}', 2);
INSERT INTO `site_setting` VALUES (8, 'badge', '徽标', '{\"title\":\"Vue.js 客户端渲染\",\"url\":\"https://cn.vuejs.org/\",\"subject\":\"SPA\",\"value\":\"Vue.js\",\"color\":\"brightgreen\"}', 2);
INSERT INTO `site_setting` VALUES (9, 'badge', '徽标', '{\"title\":\"UI 框架 Semantic-UI\",\"url\":\"https://semantic-ui.com/\",\"subject\":\"UI\",\"value\":\"Semantic-UI\",\"color\":\"semantic-ui\"}', 2);
INSERT INTO `site_setting` VALUES (10, 'badge', '徽标', '{\"title\":\"阿里云提供服务器及域名相关服务\",\"url\":\"https://www.aliyun.com/\",\"subject\":\"VPS & DNS\",\"value\":\"Aliyun\",\"color\":\"blueviolet\"}', 2);
INSERT INTO `site_setting` VALUES (11, 'badge', '徽标', '{\"title\":\"jsDelivr 提供 CDN 加速服务\",\"url\":\"https://www.jsdelivr.com/\",\"subject\":\"CDN\",\"value\":\"jsDelivr\",\"color\":\"orange\"}', 2);
INSERT INTO `site_setting` VALUES (12, 'badge', '徽标', '{\"title\":\"GitHub 提供图床\",\"url\":\"https://github.com/\",\"subject\":\"OSS\",\"value\":\"GitHub\",\"color\":\"github\"}', 2);
INSERT INTO `site_setting` VALUES (13, 'badge', '徽标', '{\"title\":\"本站点采用 CC BY 4.0 国际许可协议进行许可\",\"url\":\"https://creativecommons.org/licenses/by/4.0/\",\"subject\":\"CC\",\"value\":\"BY 4.0\",\"color\":\"lightgray\"}', 2);
INSERT INTO `site_setting` VALUES (14, 'avatar', '图片路径', '/img/avatar.jpg', 3);
INSERT INTO `site_setting` VALUES (15, 'name', '昵称', 'Naccl', 3);
INSERT INTO `site_setting` VALUES (16, 'rollText', '滚动个签', '\"云鹤当归天，天不迎我妙木仙；\",\"游龙当归海，海不迎我自来也。\"', 3);
INSERT INTO `site_setting` VALUES (17, 'github', 'GitHub地址', 'https://github.com/Naccl', 3);
INSERT INTO `site_setting` VALUES (18, 'qq', 'QQ链接', 'http://sighttp.qq.com/authd?IDKEY=', 3);
INSERT INTO `site_setting` VALUES (19, 'bilibili', 'bilibili链接', 'https://space.bilibili.com/', 3);
INSERT INTO `site_setting` VALUES (20, 'netease', '网易云音乐', 'https://music.163.com/#/user/home?id=', 3);
INSERT INTO `site_setting` VALUES (21, 'email', 'email', 'mailto:i@naccl.top', 3);
INSERT INTO `site_setting` VALUES (22, 'favorite', '自定义', '{\"title\":\"最喜欢的动漫 📺\",\"content\":\"异度侵入、春物语、NO GAME NO LIFE、实力至上主义的教室、辉夜大小姐、青春猪头少年不会梦到兔女郎学姐、路人女主、Re0、魔禁、超炮、俺妹、在下坂本、散华礼弥、OVERLORD、慎勇、人渣的本愿、白色相簿2、死亡笔记、DARLING in the FRANXX、鬼灭之刃\"}', 3);
INSERT INTO `site_setting` VALUES (23, 'favorite', '自定义', '{\"title\":\"最喜欢我的女孩子们 🤤\",\"content\":\"芙兰达、土间埋、食蜂操祈、佐天泪爷、樱岛麻衣、桐崎千棘、02、亚丝娜、高坂桐乃、五更琉璃、安乐冈花火、一色彩羽、英梨梨、珈百璃、时崎狂三、可儿那由多、和泉纱雾、早坂爱\"}', 3);
INSERT INTO `site_setting` VALUES (24, 'favorite', '自定义', '{\"title\":\"最喜欢玩的游戏 🎮\",\"content\":\"Stellaris、巫师、GTA、荒野大镖客、刺客信条、魔兽争霸、LOL、PUBG\"}', 3);
INSERT INTO `site_setting` VALUES (25, 'reward', '赞赏码路径', '/img/reward.jpg', 1);
INSERT INTO `site_setting` VALUES (26, 'commentAdminFlag', '博主评论标识', '咕咕', 1);
INSERT INTO `site_setting` VALUES (27, 'friendContent', '友链页面信息', '随机排序，不分先后。欢迎交换友链~(￣▽￣)~*\n\n* 昵称：Naccl\n* 一句话：游龙当归海，海不迎我自来也。\n* 网址：[https://naccl.top](https://naccl.top)\n* 头像URL：[https://naccl.top/img/avatar.jpg](https://naccl.top/img/avatar.jpg)\n\n仅凭个人喜好添加友链，请在收到我的回复邮件后再于贵站添加本站链接。原则上已添加的友链不会删除，如果你发现自己被移除了，恕不另行通知，只需和我一样做就好。\n\n', 4);
INSERT INTO `site_setting` VALUES (28, 'friendCommentEnabled', '友链页面评论开关', '1', 4);
COMMIT;

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of tag
-- ----------------------------
BEGIN;
INSERT INTO `tag` VALUES (1, 'python');
INSERT INTO `tag` VALUES (2, 'c++ ');
INSERT INTO `tag` VALUES (3, 'spring');
COMMIT;

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `type_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of type
-- ----------------------------
BEGIN;
INSERT INTO `type` VALUES (1, '技术博客');
INSERT INTO `type` VALUES (2, '面试');
INSERT INTO `type` VALUES (3, '心情随写');
INSERT INTO `type` VALUES (4, '学习笔记');
COMMIT;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `nickname` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '昵称',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '头像地址',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '邮箱',
  `status` int NOT NULL,
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `role` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '角色访问权限',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
BEGIN;
INSERT INTO `user` VALUES (1, 'root', '63a9f0ea7bb98050796b649e85481845', 'root', 'http://r7eb8ajdr.hd-bkt.clouddn.com/avatar/avatar9.webp', '2633622312@qq.com', 1, '2020-04-20 10:44:01', '2020-04-20 10:44:01', 'role_root');
INSERT INTO `user` VALUES (2, 'admin', '21232f297a57a5a743894a0e4a801fc3', 'Admin', 'http://r7eb8ajdr.hd-bkt.clouddn.com/img/admin.png', '2633622312@qq.com', 1, '2020-04-20 10:44:01', '2022-02-17 14:14:15', 'role_admin');
INSERT INTO `user` VALUES (3, 'user', 'ee11cbb19052e40b07aac0ca060c23ee', 'User', 'http://r7eb8ajdr.hd-bkt.clouddn.com/img/kitty.png', '2633622312@qq.com', 1, '2020-04-20 10:44:01', '2022-02-17 14:14:56', 'role_user');
INSERT INTO `user` VALUES (4, 'Visitor', '127870930d65c57ee65fcc47f2170d38', 'vistor', 'http://r7eb8ajdr.hd-bkt.clouddn.com/img/mouse.jpeg', '2633622312@qq.com', 1, '2020-04-20 10:44:01', '2022-02-17 14:15:30', 'role_guest');
COMMIT;

-- ----------------------------
-- Table structure for visit_log
-- ----------------------------
DROP TABLE IF EXISTS `visit_log`;
CREATE TABLE `visit_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `uuid` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '访客标识码',
  `uri` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求接口',
  `method` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求方式',
  `param` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '请求参数',
  `behavior` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '访问行为',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '访问内容',
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '备注',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '浏览器',
  `times` int NOT NULL COMMENT '请求耗时（毫秒）',
  `create_time` datetime NOT NULL COMMENT '访问时间',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of visit_log
-- ----------------------------
BEGIN;
COMMIT;

-- ----------------------------
-- Table structure for visitor
-- ----------------------------
DROP TABLE IF EXISTS `visitor`;
CREATE TABLE `visitor` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `uuid` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '访客标识码',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'ip',
  `ip_source` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'ip来源',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '浏览器',
  `create_time` datetime NOT NULL COMMENT '首次访问时间',
  `last_time` datetime NOT NULL COMMENT '最后访问时间',
  `pv` int DEFAULT NULL COMMENT '访问页数统计',
  `user_agent` varchar(2000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT 'user-agent用户代理',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of visitor
-- ----------------------------
BEGIN;
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
